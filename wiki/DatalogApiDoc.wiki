#summary datalog API Reference
#sidebar ApiDocSidebar

<wiki:comment>
This document was auto-generated from the clojure.contrib source by contrib-autodoc.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
</wiki:comment>
=API for datalog=
Usage: 
{{{
(ns <your-namespace>
  (:use clojure.contrib.datalog))
}}}


==Public Variables and Functions==
Shortcuts:
[#(_build-work-plan_rules_query) build-work-plan] [#(_run-work-plan_work-plan_database_query-bindings) run-work-plan] 

Variables and Functions in datalog.database:
[DatalogApiDoc#(_add-index_db_name_key) add-index] [DatalogApiDoc#(_add-relation_db_name_keys) add-relation] [DatalogApiDoc#(_add-tuple_db_rel-name_tuple) add-tuple] [DatalogApiDoc#(_add-tuples_db_&_tupls) add-tuples] [DatalogApiDoc#(_any-match?_db_rn_pt) any-match?] [DatalogApiDoc#(_database-counts_db) database-counts] [DatalogApiDoc#(_database-merge_dbs) database-merge] [DatalogApiDoc#(_database-merge-parallel_dbs) database-merge-parallel] [DatalogApiDoc#(_datalog-relation_schema_data_indexes) datalog-relation] [DatalogApiDoc#(_ensure-relation_db_name_keys_indexes) ensure-relation] [DatalogApiDoc#(_get-relation_db_rel-name) get-relation] [DatalogApiDoc#(_make-database_&_commands) make-database] [DatalogApiDoc#(_merge-relations_r1_r2) merge-relations] [DatalogApiDoc#(_remove-tuple_db_rel-name_tuple) remove-tuple] [DatalogApiDoc#(_replace-relation_db_rel-name_rel) replace-relation] [DatalogApiDoc#(_select_db_rn_pt) select] 

Variables and Functions in datalog.literals:
[DatalogApiDoc#adorned-literal adorned-literal] [DatalogApiDoc#(_build-atom_f_type) build-atom] [DatalogApiDoc#build-literal build-literal] [DatalogApiDoc#(_build-seed-bindings_s) build-seed-bindings] [DatalogApiDoc#(_delta-literal_l) delta-literal] [DatalogApiDoc#display-literal display-literal] [DatalogApiDoc#(_get-adorned-bindings_pred) get-adorned-bindings] [DatalogApiDoc#(_get-base-predicate_pred) get-base-predicate] [DatalogApiDoc#get-cs-from-vs get-cs-from-vs] [DatalogApiDoc#get-self-bound-cs get-self-bound-cs] [DatalogApiDoc#get-vs-from-cs get-vs-from-cs] [DatalogApiDoc#join-literal join-literal] [DatalogApiDoc#literal-appropriate? literal-appropriate?] [DatalogApiDoc#literal-columns literal-columns] [DatalogApiDoc#(_literal-magic?_lit) literal-magic?] [DatalogApiDoc#literal-predicate literal-predicate] [DatalogApiDoc#literal-vars literal-vars] [DatalogApiDoc#(_magic-literal_l) magic-literal] [DatalogApiDoc#(_negated-literal_l) negated-literal] [DatalogApiDoc#(_negated?_l) negated?] [DatalogApiDoc#negative-vars negative-vars] [DatalogApiDoc#positive-vars positive-vars] [DatalogApiDoc#(_positive?_l) positive?] [DatalogApiDoc#(_project-literal_db_lit_bs) project-literal] 

Variables and Functions in datalog.magic:
[DatalogApiDoc#(_adorn-query_q) adorn-query] [DatalogApiDoc#(_adorn-rules-set_rs_q) adorn-rules-set] [DatalogApiDoc#(_build-partial-tuple_q_bindings) build-partial-tuple] [DatalogApiDoc#(_magic-transform_rs) magic-transform] [DatalogApiDoc#(_seed-predicate-for-insertion_q) seed-predicate-for-insertion] [DatalogApiDoc#(_seed-relation_q) seed-relation] [DatalogApiDoc#(_seed-rule_q) seed-rule] 

Variables and Functions in datalog.rules:
[DatalogApiDoc#(_<-_hd_&_body) <-] [DatalogApiDoc#(_?-_&_q) ?-] [DatalogApiDoc#(_all-predicates_rs) all-predicates] [DatalogApiDoc#(_apply-rule_db_rule) apply-rule] [DatalogApiDoc#(_compute-sip_bindings_i-preds_rule) compute-sip] [DatalogApiDoc#(_display-query_query) display-query] [DatalogApiDoc#(_display-rule_rule) display-rule] [DatalogApiDoc#(_is-safe?_rule) is-safe?] [DatalogApiDoc#(_make-rules-set_rs) make-rules-set] [DatalogApiDoc#(_non-base-rules_rs) non-base-rules] [DatalogApiDoc#(_predicate-map_rs) predicate-map] [DatalogApiDoc#(_return-rule-data_rule) return-rule-data] [DatalogApiDoc#(_rules-set_&_rules) rules-set] 

Variables and Functions in datalog.softstrat:
[DatalogApiDoc#(_build-soft-strat-work-plan_rs_q) build-soft-strat-work-plan] [DatalogApiDoc#(_get-all-relations_ws) get-all-relations] 

Variables and Functions in datalog.util:
[DatalogApiDoc#(_is-query-var?_sym) is-query-var?] [DatalogApiDoc#(_is-var?_sym) is-var?] [DatalogApiDoc#(_keys-to-vals_m_ks) keys-to-vals] [DatalogApiDoc#(_map-values_f_hash) map-values] [DatalogApiDoc#(_preduce_f_data) preduce] [DatalogApiDoc#(_reverse-map_m) reverse-map] [DatalogApiDoc#(_trace-datalog_&_body) trace-datalog] 

----
===(`_`build-work-plan`_` rules query)===
<pre> Given a list of rules and a query, build a work plan that can be
used to execute the query.</pre>
----
===(`_`run-work-plan`_` work-plan database query-bindings)===
<pre> Given a work plan, a database, and some query bindings, run the
work plan and return the results.</pre>
==Namespace clojure.contrib.datalog.database==
----
===(`_`add-index`_` db name key)===
<pre> Adds an index to an empty relation named name</pre>
----
===(`_`add-relation`_` db name keys)===
<pre> Adds a relation to the database</pre>
----
===(`_`add-tuple`_` db rel-name tuple)===
===(`_`add-tuple`_` rel tuple)===
<pre> Two forms:

 `[`db relation-name tuple`]` adds tuple to the named relation.  Returns
the new database.

 `[`rel tuple`]` adds to the relation object.  Returns the new relation.</pre>
----
===(`_`add-tuples`_` db & tupls)===
<pre> Adds a collection of tuples to the db, as
(add-tuples db
   `[`:rel-name :key-1 1 :key-2 2`]`
   `[`:rel-name :key-1 2 :key-2 3`]`)</pre>
----
===(`_`any-match?`_` db rn pt)===
<pre> Finds if there are any matching records for the partial tuple</pre>
----
===(`_`database-counts`_` db)===
<pre> Returns a map with the count of elements in each relation.</pre>
----
===(`_`database-merge`_` dbs)===
<pre> Merges databases together</pre>
----
===(`_`database-merge-parallel`_` dbs)===
<pre> Merges databases together in parallel</pre>
----
===(`_`datalog-relation`_` schema data indexes)===
<pre> Creates a relation</pre>
----
===(`_`ensure-relation`_` db name keys indexes)===
<pre> If the database lacks the named relation, add it</pre>
----
===(`_`get-relation`_` db rel-name)===
<pre> Get a relation object by name</pre>
----
===(`_`make-database`_` & commands)===
====Macro====
<pre> Makes a database, like this
(make-database
  (relation :fred `[`:mary :sue`]`)
  (index :fred :mary)
  (relation :sally `[`:jen :becky`]`)
  (index :sally :jen)
  (index :sally :becky))</pre>
----
===(`_`merge-relations`_` r1 r2)===
<pre> Merges two relations</pre>
----
===(`_`remove-tuple`_` db rel-name tuple)===
===(`_`remove-tuple`_` rel tuple)===
<pre> Two forms:

 `[`db relation-name tuple`]` removes the tuple from the named relation,
returns a new database.

 `[`rel tuple`]` removes the tuple from the relation.  Returns the new
relation.</pre>
----
===(`_`replace-relation`_` db rel-name rel)===
<pre> Add or replace a fully constructed relation object to the database.</pre>
----
===(`_`select`_` db rn pt)===
<pre> finds all matching tuples to the partial tuple (pt) in the relation named (rn)</pre>
==Namespace clojure.contrib.datalog.literals==
----
===`_`adorned-literal`_`===
<pre> When passed a set of bound columns, returns the adorned literal</pre>
----
===(`_`build-atom`_` f type)===
<pre> Returns an unevaluated expression (to be used in a macro) of an
atom.</pre>
----
===`_`build-literal`_`===
<pre> (Returns an unevaluated expression (to be used in macros) of a
literal.</pre>
----
===(`_`build-seed-bindings`_` s)===
<pre> Given a seed literal, already adorned and in magic form, convert
its bound constants to new variables.</pre>
----
===(`_`delta-literal`_` l)===
<pre> Given a literal l, return a delta version</pre>
----
===`_`display-literal`_`===
<pre> Converts a struct representing a literal to a normal list</pre>
----
===(`_`get-adorned-bindings`_` pred)===
<pre> Get the bindings from this adorned literal.</pre>
----
===(`_`get-base-predicate`_` pred)===
<pre> Get the base predicate from this predicate.</pre>
----
===`_`get-cs-from-vs`_`===
<pre> From a set of vars, get the columns</pre>
----
===`_`get-self-bound-cs`_`===
<pre> Get the columns that are bound withing the literal.</pre>
----
===`_`get-vs-from-cs`_`===
<pre> From a set of columns, return the vars</pre>
----
===`_`join-literal`_`===
<pre> Given a database (db), a literal (lit) and a seq of bindings (bs),
return a new seq of bindings by joining this literal.</pre>
----
===`_`literal-appropriate?`_`===
<pre> When passed a set of bound vars, determines if this literal can be
used during this point of a SIP computation.</pre>
----
===`_`literal-columns`_`===
<pre> Return the column names this applies to</pre>
----
===(`_`literal-magic?`_` lit)===
<pre> Is this literal magic?</pre>
----
===`_`literal-predicate`_`===
<pre> Return the predicate/relation this conditional operates over</pre>
----
===`_`literal-vars`_`===
<pre> Returns the logic vars used by this literal</pre>
----
===(`_`magic-literal`_` l)===
<pre> Create a magic version of this adorned predicate.</pre>
----
===(`_`negated-literal`_` l)===
<pre> Given a literal l, return a negated version</pre>
----
===(`_`negated?`_` l)===
<pre> Is this literal a negated literal?</pre>
----
===`_`negative-vars`_`===
<pre> Returns the logic vars used in a negative position</pre>
----
===`_`positive-vars`_`===
<pre> Returns the logic vars used in a positive position</pre>
----
===(`_`positive?`_` l)===
<pre> Is this a positive literal?</pre>
----
===(`_`project-literal`_` db lit bs)===
===(`_`project-literal`_` db lit bs var?)===
<pre> Project a stream of bindings onto a literal/relation. Returns a new
db.</pre>
==Namespace clojure.contrib.datalog.magic==
----
===(`_`adorn-query`_` q)===
<pre> Adorn a query</pre>
----
===(`_`adorn-rules-set`_` rs q)===
<pre> Adorns the given rules-set for the given query.  (rs) is a
rules-set, (q) is an adorned query.</pre>
----
===(`_`build-partial-tuple`_` q bindings)===
<pre> Given a query and a set of bindings, build a partial tuple needed
to extract the relation from the database.</pre>
----
===(`_`magic-transform`_` rs)===
===(`_`magic-transform`_` rs i-preds)===
<pre> Return a magic transformation of an adorned rules-set (rs).  The
(i-preds) are the predicates of the intension database.  These
default to the predicates within the rules-set.</pre>
----
===(`_`seed-predicate-for-insertion`_` q)===
<pre> Given a query, return the predicate to use for database insertion.</pre>
----
===(`_`seed-relation`_` q)===
<pre> Given a magic form of a query, give back the literal form of its seed
relation</pre>
----
===(`_`seed-rule`_` q)===
<pre> Given an adorned query, give back its seed rule</pre>
==Namespace clojure.contrib.datalog.rules==
----
===(`_`<-`_` hd & body)===
====Macro====
<pre> Build a datalog rule.  Like this:

 (<- (:head :x ?x :y ?y) (:body-1 :x ?x :y ?y) (:body-2 :z ?z) (not! :body-3 :x ?x) (if > ?y ?z))</pre>
----
===(`_`?-`_` & q)===
====Macro====
<pre> Define a datalog query</pre>
----
===(`_`all-predicates`_` rs)===
<pre> Given a rules-set, return all defined predicates</pre>
----
===(`_`apply-rule`_` db rule)===
===(`_`apply-rule`_` db-1 db-2 rule)===
<pre> Apply the rule against db-1, adding the results to the appropriate
relation in db-2.  The relation will be created if needed.</pre>
----
===(`_`compute-sip`_` bindings i-preds rule)===
<pre> Given a set of bound column names, return an adorned sip for this
rule.  A set of intensional predicates should be provided to
determine what should be adorned.</pre>
----
===(`_`display-query`_` query)===
<pre> Return a query in a readable format.</pre>
----
===(`_`display-rule`_` rule)===
<pre> Return the rule in a readable format.</pre>
----
===(`_`is-safe?`_` rule)===
<pre> Is the rule safe according to the datalog protocol?</pre>
----
===(`_`make-rules-set`_` rs)===
<pre> Given an existing set of rules, make it a 'rules-set' for
printing.</pre>
----
===(`_`non-base-rules`_` rs)===
<pre> Return a collection of rules that depend, somehow, on other rules</pre>
----
===(`_`predicate-map`_` rs)===
<pre> Given a rules-set, return a map of rules keyed by their predicates.
Each value will be a set of rules.</pre>
----
===(`_`return-rule-data`_` rule)===
<pre> Returns an untypted rule that will be fully printed</pre>
----
===(`_`rules-set`_` & rules)===
<pre> Given a collection of rules return a rules set</pre>
==Namespace clojure.contrib.datalog.softstrat==
----
===(`_`build-soft-strat-work-plan`_` rs q)===
<pre> Return a work plan for the given rules-set and query</pre>
----
===(`_`get-all-relations`_` ws)===
<pre> Return a set of all relation names defined in this workplan</pre>
==Namespace clojure.contrib.datalog.util==
----
===(`_`is-query-var?`_` sym)===
<pre> Is this a query variable: e.g. a symbol prefixed with ??</pre>
----
===(`_`is-var?`_` sym)===
<pre> Is this a logic variable: e.g. a symbol prefixed with a ?</pre>
----
===(`_`keys-to-vals`_` m ks)===
<pre> Given a map and a collection of keys, return the collection of vals</pre>
----
===(`_`map-values`_` f hash)===
<pre> Like map, but works over the values of a hash map</pre>
----
===(`_`preduce`_` f data)===
<pre> Similar to merge-with, but the contents of each key are merged in
parallel using f.

 f - a function of 2 arguments.
data - a collection of hashes.</pre>
----
===(`_`reverse-map`_` m)===
<pre> Reverse the keys/values of a map</pre>
----
===(`_`trace-datalog`_` & body)===
====Macro====
<pre> If `*`test-datalog`*` is set to true, run the enclosed commands</pre>
