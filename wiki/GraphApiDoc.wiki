#summary graph API Reference
#sidebar ApiDocSidebar

<wiki:comment>
This document was auto-generated from the clojure.contrib source by contrib-autodoc.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
</wiki:comment>
=API for graph=
Usage: 
{{{
(ns <your-namespace>
  (:use clojure.contrib.graph))
}}}


==Public Variables and Functions==
Shortcuts:
[#add-loops add-loops] [#component-graph component-graph] [#dependency-list dependency-list] [#fixed-point fixed-point] [#get-neighbors get-neighbors] [#lazy-walk lazy-walk] [#post-ordered-nodes post-ordered-nodes] [#recursive-component? recursive-component?] [#remove-loops remove-loops] [#reverse-graph reverse-graph] [#scc scc] [#self-recursive-sets self-recursive-sets] [#stratification-list stratification-list] [#transitive-closure transitive-closure] 

----
===add-loops===
====function====
<pre>
Usage: *(_add-loops_ g)*
</pre>
<pre>For each node n, add the edge n->n if not already present.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#46 Source] [http://www.google.com/codesearch?hl=en&lr=&q=add-loops+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===component-graph===
====function====
<pre>
Usage: *(_component-graph_ g)
       (_component-graph_ g sccs)*
</pre>
<pre>Given a graph, perhaps with cycles, return a reduced graph that is acyclic. 
Each node in the new graph will be a set of nodes from the old. 
These sets are the strongly connected components.  Each edge will 
be the union of the corresponding edges of the prior graph.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#130 Source] [http://www.google.com/codesearch?hl=en&lr=&q=component-graph+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===dependency-list===
====function====
<pre>
Usage: *(_dependency-list_ g)*
</pre>
<pre>Similar to a topological sort, this returns a vector of sets. The 
set of nodes at index 0 are independent.  The set at index 1 depend 
on index 0; those at 2 depend on 0 and 1, and so on.  Those withing 
a set have no mutual dependencies.  Assume the input graph (which 
much be acyclic) has an edge a->b when a depends on b.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#187 Source] [http://www.google.com/codesearch?hl=en&lr=&q=dependency-list+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===fixed-point===
====function====
<pre>
Usage: *(_fixed-point_ data fun max equal)*
</pre>
<pre>Repeatedly apply fun to data until (equal old-data new-data) 
returns true.  If max iterations occur, it will throw an 
exception.  Set max to nil for unlimited iterations.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#164 Source] [http://www.google.com/codesearch?hl=en&lr=&q=fixed-point+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===get-neighbors===
====function====
<pre>
Usage: *(_get-neighbors_ g n)*
</pre>
<pre>Get the neighbors of a node.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#26 Source] [http://www.google.com/codesearch?hl=en&lr=&q=get-neighbors+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===lazy-walk===
====function====
<pre>
Usage: *(_lazy-walk_ g n)
       (_lazy-walk_ g ns v)*
</pre>
<pre>Return a lazy sequence of the nodes of a graph starting a node n.  Optionally, 
provide a set of visited notes (v) and a collection of nodes to 
visit (ns).</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#65 Source] [http://www.google.com/codesearch?hl=en&lr=&q=lazy-walk+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===post-ordered-nodes===
====function====
<pre>
Usage: *(_post-ordered-nodes_ g)*
</pre>
<pre>Return a sequence of indexes of a post-ordered walk of the graph.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#107 Source] [http://www.google.com/codesearch?hl=en&lr=&q=post-ordered-nodes+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===recursive-component?===
====function====
<pre>
Usage: *(_recursive-component?_ g ns)*
</pre>
<pre>Is the component (recieved from scc) self recursive?</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#148 Source] [http://www.google.com/codesearch?hl=en&lr=&q=recursive-component?+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===remove-loops===
====function====
<pre>
Usage: *(_remove-loops_ g)*
</pre>
<pre>For each node n, remove any edges n->n.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#54 Source] [http://www.google.com/codesearch?hl=en&lr=&q=remove-loops+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===reverse-graph===
====function====
<pre>
Usage: *(_reverse-graph_ g)*
</pre>
<pre>Given a directed graph, return another directed graph with the 
order of the edges reversed.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#34 Source] [http://www.google.com/codesearch?hl=en&lr=&q=reverse-graph+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===scc===
====function====
<pre>
Usage: *(_scc_ g)*
</pre>
<pre>Returns, as a sequence of sets, the strongly connected components 
of g.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#114 Source] [http://www.google.com/codesearch?hl=en&lr=&q=scc+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===self-recursive-sets===
====function====
<pre>
Usage: *(_self-recursive-sets_ g)*
</pre>
<pre>Returns, as a sequence of sets, the components of a graph that are 
self-recursive.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#155 Source] [http://www.google.com/codesearch?hl=en&lr=&q=self-recursive-sets+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===stratification-list===
====function====
<pre>
Usage: *(_stratification-list_ g1 g2)*
</pre>
<pre>Similar to dependency-list (see doc), except two graphs are 
provided.  The first is as dependency-list.  The second (which may 
have cycles) provides a partial-dependency relation.  If node a 
depends on node b (meaning an edge a->b exists) in the second 
graph, node a must be equal or later in the sequence.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#204 Source] [http://www.google.com/codesearch?hl=en&lr=&q=stratification-list+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===transitive-closure===
====function====
<pre>
Usage: *(_transitive-closure_ g)*
</pre>
<pre>Returns the transitive closure of a graph.  The neighbors are lazily computed. 
 
Note: some version of this algorithm return all edges a->a 
regardless of whether such loops exist in the original graph.  This 
version does not.  Loops will be included only if produced by 
cycles in the graph.  If you have code that depends on such 
behavior, call (-> g transitive-closure add-loops)</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph/clojure/contrib/graph.clj#78 Source] [http://www.google.com/codesearch?hl=en&lr=&q=transitive-closure+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
