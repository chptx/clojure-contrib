#summary graph API Reference
#sidebar ApiDocSidebar

<wiki:comment>
This document was auto-generated from the clojure.contrib source by contrib-autodoc.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
</wiki:comment>
=API for graph=
Usage: 
{{{
(ns <your-namespace>
  (:use clojure.contrib.graph))
}}}


==Public Variables and Functions==
Shortcuts:
[#(_add-loops_g) add-loops] [#(_component-graph_g) component-graph] [#(_dependency-list_g) dependency-list] [#(_fixed-point_data_fun_max_equal) fixed-point] [#(_get-neighbors_g_n) get-neighbors] [#(_lazy-walk_g_n) lazy-walk] [#(_post-ordered-nodes_g) post-ordered-nodes] [#(_recursive-component?_g_ns) recursive-component?] [#(_remove-loops_g) remove-loops] [#(_reverse-graph_g) reverse-graph] [#(_scc_g) scc] [#(_self-recursive-sets_g) self-recursive-sets] [#(_stratification-list_g1_g2) stratification-list] [#(_transitive-closure_g) transitive-closure] 

----
===(_add-loops_ g)===
<pre> For each node n, add the edge n->n if not already present.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#46 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]add-loops([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_component-graph_ g)===
===(_component-graph_ g sccs)===
<pre> Given a graph, perhaps with cycles, return a reduced graph that is acyclic.
Each node in the new graph will be a set of nodes from the old.
These sets are the strongly connected components.  Each edge will
be the union of the corresponding edges of the prior graph.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#130 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]component-graph([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_dependency-list_ g)===
<pre> Similar to a topological sort, this returns a vector of sets. The
set of nodes at index 0 are independent.  The set at index 1 depend
on index 0; those at 2 depend on 0 and 1, and so on.  Those withing
a set have no mutual dependencies.  Assume the input graph (which
much be acyclic) has an edge a->b when a depends on b.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#187 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]dependency-list([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_fixed-point_ data fun max equal)===
<pre> Repeatedly apply fun to data until (equal old-data new-data)
returns true.  If max iterations occur, it will throw an
exception.  Set max to nil for unlimited iterations.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#164 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]fixed-point([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_get-neighbors_ g n)===
<pre> Get the neighbors of a node.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#26 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]get-neighbors([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_lazy-walk_ g n)===
===(_lazy-walk_ g ns v)===
<pre> Return a lazy sequence of the nodes of a graph starting a node n.  Optionally,
provide a set of visited notes (v) and a collection of nodes to
visit (ns).</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#65 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]lazy-walk([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_post-ordered-nodes_ g)===
<pre> Return a sequence of indexes of a post-ordered walk of the graph.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#107 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]post-ordered-nodes([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_recursive-component?_ g ns)===
<pre> Is the component (recieved from scc) self recursive?</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#148 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]recursive-component?([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_remove-loops_ g)===
<pre> For each node n, remove any edges n->n.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#54 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]remove-loops([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_reverse-graph_ g)===
<pre> Given a directed graph, return another directed graph with the
order of the edges reversed.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#34 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]reverse-graph([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_scc_ g)===
<pre> Returns, as a sequence of sets, the strongly connected components
of g.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#114 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]scc([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_self-recursive-sets_ g)===
<pre> Returns, as a sequence of sets, the components of a graph that are
self-recursive.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#155 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]self-recursive-sets([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_stratification-list_ g1 g2)===
<pre> Similar to dependency-list (see doc), except two graphs are
provided.  The first is as dependency-list.  The second (which may
have cycles) provides a partial-dependency relation.  If node a
depends on node b (meaning an edge a->b exists) in the second
graph, node a must be equal or later in the sequence.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#204 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]stratification-list([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]----
===(_transitive-closure_ g)===
<pre> Returns the transitive closure of a graph.  The neighbors are lazily computed.

 Note: some version of this algorithm return all edges a->a
regardless of whether such loops exist in the original graph.  This
version does not.  Loops will be included only if produced by
cycles in the graph.  If you have code that depends on such
behavior, call (-> g transitive-closure add-loops)</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/graph.clj#78 Source] [http://www.google.com/codesearch?hl=en&lr=&q=[^-*a-zA-Z]transitive-closure([^-*a-zA-Z]|%24)+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]