#summary monads API Reference
#sidebar ApiDocSidebar

<wiki:comment>
This document was auto-generated from the clojure.contrib source by contrib-autodoc.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
</wiki:comment>
=API for monads=
Usage: 
{{{
(ns <your-namespace>
  (:use clojure.contrib.monads))
}}}


==Public Variables and Functions==
Shortcuts:
[#(_call-cc_f) call-cc] [#cont-m cont-m] [#(_defmonad_name_doc-string_operations) defmonad] [#(_defmonadfn_name_docstring?_attr-map?_args_expr) defmonadfn] [#(_domonad_steps_expr) domonad] [#identity-m identity-m] [#(_m-chain_steps) m-chain] [#(_m-fmap_f_m) m-fmap] [#(_m-join_m) m-join] [#(_m-lift_n_f) m-lift] [#(_m-map_f_xs) m-map] [#(_m-reduce_f_mvs) m-reduce] [#(_m-seq_ms) m-seq] [#(_m-when_test_m-expr) m-when] [#(_m-when-not_test_m-expr) m-when-not] [#maybe-m maybe-m] [#(_maybe-t_m) maybe-t] [#(_monad_operations) monad] [#(_run-cont_c) run-cont] [#sequence-m sequence-m] [#(_sequence-t_m) sequence-t] [#set-m set-m] [#state-m state-m] [#(_state-t_m) state-t] [#(_with-monad_name_&_exprs) with-monad] [#(_writer-m_empty-accumulator) writer-m] 

----
===(_call-cc_ f)===
<pre> A computation in the cont monad that calls function f with a single
argument representing the current continuation. The function f should
return a continuation (which becomes the return value of call-cc),
or call the passed-in current continuation to terminate.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#383 Source]
----
===_cont-m_===
<pre> Monad describing computations in continuation-passing style. The monadic
values are functions that are called with a single argument representing
the continuation of the computation, to which they pass their result.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#367 Source]
----
===(_defmonad_ name doc-string operations)===
===(_defmonad_ name operations)===
====Macro====
<pre> Define a named monad by defining the monad operations. The definitions
are written like bindings to the monad operations m-bind and
m-result (required) and m-zero and m-plus (optional).</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#39 Source]
----
===(_defmonadfn_ name docstring? attr-map? args expr)===
===(_defmonadfn_ name docstring? attr-map? (args expr) ...)===
====Macro====
<pre> Like defn, but for functions that use monad operations and are used inside
a with-monad block.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#124 Source]
----
===(_domonad_ steps expr)===
===(_domonad_ name steps expr)===
====Macro====
<pre> Monad comprehension. Takes the name of a monad, a vector of steps
given as binding-form/monadic-expression pairs, and a result value
specified by expr. The monadic-expression terms can use the binding
variables of the previous steps.
If the monad contains a definition of m-zero, the step list can also
contain conditions of the form :when p, where the predicate p can
contain the binding variables from all previous steps.
A clause of the form :let `[`binding-form expr ...`]`, where the bindings
are given as a vector as for the use in let, establishes additional
bindings that can be used in the following steps.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#101 Source]
----
===_identity-m_===
<pre> Monad describing plain computations. This monad does in fact nothing
at all. It is useful for testing, for combination with monad
transformers, and for code that is parameterized with a monad.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#242 Source]
----
===(_m-chain_ steps)===
====Macro====
<pre> Chains together monadic computation steps that are each functions
of one parameter. Each step is called with the result of the previous
step as its argument. (m-chain (step1 step2)) is equivalent to
(fn `[`x`]` (domonad `[`r1 (step1 x) r2 (step2 r1)`]` r2)).</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#199 Source]
----
===(_m-fmap_ f m)===
====Macro====
<pre> Bind the monadic value m to the function returning (f x) for argument x</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#177 Source]
----
===(_m-join_ m)===
====Macro====
<pre> Converts a monadic value containing a monadic value into a 'simple'
monadic value.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#171 Source]
----
===(_m-lift_ n f)===
====Macro====
<pre> Converts a function f of n arguments into a function of n
monadic arguments returning a monadic value.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#162 Source]
----
===(_m-map_ f xs)===
====Macro====
<pre> 'Executes' the sequence of monadic values resulting from mapping
f onto the values xs. f must return a monadic value.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#193 Source]
----
===(_m-reduce_ f mvs)===
===(_m-reduce_ f val mvs)===
====Macro====
<pre> Return the reduction of (m-lift 2 f) over the list of monadic values mvs
with initial value (m-result val).</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#210 Source]
----
===(_m-seq_ ms)===
====Macro====
<pre> 'Executes' the monadic values in ms and returns a sequence of the
basic values contained in them.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#182 Source]
----
===(_m-when_ test m-expr)===
====Macro====
<pre> If test if logical true, return monadic value m-expr, else return
(m-result nil).</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#223 Source]
----
===(_m-when-not_ test m-expr)===
====Macro====
<pre> If test if logical false, return monadic value m-expr, else return
(m-result nil).</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#229 Source]
----
===_maybe-m_===
<pre> Monad describing computations with possible failures. Failure is
represented by nil, any other value is considered valid. As soon as
a step returns nil, the whole computation will yield nil as well.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#252 Source]
----
===(_maybe-t_ m)===
===(_maybe-t_ m nothing)===
===(_maybe-t_ m nothing which-m-plus)===
<pre> Monad transformer that transforms a monad m into a monad in which
the base values can be invalid (represented by nothing, which defaults
to nil). The third argument chooses if m-zero and m-plus are inherited
from the base monad (use :m-plus-from-base) or adopt maybe-like
behaviour (use :m-plus-from-maybe). The default is :m-plus-from-base
if the base monad m has a definition for m-plus, and :m-plus-from-maybe
otherwise.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#401 Source]
----
===(_monad_ operations)===
====Macro====
<pre> Define a monad by defining the monad operations. The definitions
are written like bindings to the monad operations m-bind and
m-result (required) and m-zero and m-plus (optional).</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#24 Source]
----
===(_run-cont_ c)===
<pre> Execute the computation c in the cont monad and return its result.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#378 Source]
----
===_sequence-m_===
<pre> Monad describing multi-valued computations, i.e. computations
that can yield multiple values. Any object implementing the seq
protocol can be used as a monadic value.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#265 Source]
----
===(_sequence-t_ m)===
<pre> Monad transformer that transforms a monad m into a monad in which
the base values are sequences.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#448 Source]
----
===_set-m_===
<pre> Monad describing multi-valued computations, like sequence-m,
but returning sets of results instead of sequences of results.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#279 Source]
----
===_state-m_===
<pre> Monad describing stateful computations. The monadic values have the
structure (fn `[`old-state`]` (list result new-state)).</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#292 Source]
----
===(_state-t_ m)===
<pre> Monad transformer that transforms a monad m into a monad of stateful
computations that have the base monad type as their result.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#463 Source]
----
===(_with-monad_ name & exprs)===
====Macro====
<pre> Evaluates an expression after replacing the keywords defining the
monad operations by the functions associated with these keywords
in the monad definition given by name.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#90 Source]
----
===(_writer-m_ empty-accumulator)===
<pre> Monad describing computations that accumulate data on the side, e.g. for
logging. The monadic values have the structure `[`value log`]`. Any of the
accumulators from clojure.contrib.accumulators can be used for storing the
log data. Its empty value is passed as a parameter.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/monads.clj#340 Source]
