#summary An overview of the clojure.contrib library
#sidebar ApiDocSidebar

<wiki:comment>
This document was auto-generated from the clojure.contrib source by contrib-autodoc.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
</wiki:comment>
=The User Contributions Library, clojure.contrib=
The user contributions library, clojure.contrib, is a collection
of namespaces each of which implements features that we believe may be useful to 
a large part of the clojure community. 

This library was created by Rich Hickey but has been populated and is maintained by a 
group of volunteers who are excited about the success of the Clojure language and 
want to do our part to help it along. The current list of contributors is available 
on the [http://code.google.com/p/clojure-contrib/ clojure.contrib home page].

More contributions (and contributors) are welcome. If you wish to contribute, you will need
to sign a contributor agreement (which allows Clojure and clojure.contrib to proceed
without entanglements, see [http://clojure.org/contributing contributing] for more info). 
The best way to start is to share a project you've written with the google group and gauge
the interest in adding it to contrib. (Publishing it in an open source form on google code,
github or some other easy-to-access place in the net will also help.) After general 
discussion, Rich Hickey makes the final determination about what gets added to 
clojure.contrib.

Some parts of clojure.contrib may migrate into clojure.core if they prove to be so 
generally useful that they justify being everywhere. (For example, condp started out
as an extension in contrib, but was moved to core by popular acclamation.)

The exact role of clojure.contrib and the future of the Clojure environment (standard 
libraries, dependency models, packaging systems, etc.)
is the subject of pretty much continuous discussion
in the clojure google group and in #clojure on freenode. Feel free to join that 
discussion and help shape the ways Clojure is extended.

Like Clojure itself, clojure.contrib is made available under the [http://opensource.org/licenses/eclipse-1.0.php Eclipse Public License (EPL)]. 
clojure.contrib is copyright 2008-2009 Rich Hickey and the various contributers.
=Summary of the Namespaces in clojure.contrib=
----
===accumulators===
by Konrad Hinsen<br>
API Overview [AccumulatorsApiDoc here]

<pre> A generic accumulator interface and implementations of various 
accumulators.</pre>
Public Variables and Functions:
[AccumulatorsApiDoc#add add] [AccumulatorsApiDoc#add-items add-items] [AccumulatorsApiDoc#combine combine] [AccumulatorsApiDoc#empty-counter empty-counter] [AccumulatorsApiDoc#empty-counter-with-total empty-counter-with-total] [AccumulatorsApiDoc#empty-list empty-list] [AccumulatorsApiDoc#empty-map empty-map] [AccumulatorsApiDoc#empty-maximum empty-maximum] [AccumulatorsApiDoc#empty-mean-variance empty-mean-variance] [AccumulatorsApiDoc#empty-min-max empty-min-max] [AccumulatorsApiDoc#empty-minimum empty-minimum] [AccumulatorsApiDoc#empty-product empty-product] [AccumulatorsApiDoc#empty-queue empty-queue] [AccumulatorsApiDoc#empty-set empty-set] [AccumulatorsApiDoc#empty-string empty-string] [AccumulatorsApiDoc#empty-sum empty-sum] [AccumulatorsApiDoc#empty-tuple empty-tuple] [AccumulatorsApiDoc#empty-vector empty-vector] 

----
===agent-utils===
by Christophe Grande<br>
API Overview [AgentUtilsApiDoc here]

<pre> Miscellaneous agent utilities 
(note to other contrib members: feel free to add to this lib)</pre>
Public Variables and Functions:
[AgentUtilsApiDoc#capture-and-send capture-and-send] 

----
===classpath===
by Stuart Sierra<br>
API Overview [ClasspathApiDoc here]

<pre> Utilities for dealing with the JVM's classpath</pre>
Public Variables and Functions:
[ClasspathApiDoc#classpath classpath] [ClasspathApiDoc#classpath-directories classpath-directories] [ClasspathApiDoc#classpath-jarfiles classpath-jarfiles] 

----
===combinatorics===
by Mark Engelberg<br>
API Overview [CombinatoricsApiDoc here]

<pre> Efficient, functional algorithms for generating lazy 
sequences for common combinatorial functions. (See the source code  
for a longer description.)</pre>
Public Variables and Functions:
[CombinatoricsApiDoc#cartesian-product cartesian-product] [CombinatoricsApiDoc#combinations combinations] [CombinatoricsApiDoc#lex-permutations lex-permutations] [CombinatoricsApiDoc#permutations permutations] [CombinatoricsApiDoc#selections selections] [CombinatoricsApiDoc#subsets subsets] 

----
===command-line===
by Chris Houser<br>
API Overview [CommandLineApiDoc here]

<pre> Process command-line arguments according to a given cmdspec</pre>
Public Variables and Functions:
[CommandLineApiDoc#with-command-line with-command-line] 

----
===complex-numbers===
by Konrad Hinsen<br>
API Overview [ComplexNumbersApiDoc here]

<pre> Complex numbers 
NOTE: This library is in evolution. Most math functions are 
      not implemented yet.</pre>
----
===cond===
by Stephen C. Gilardi<br>
API Overview [CondApiDoc here]

<pre> Extensions to the basic cond function.</pre>
Public Variables and Functions:
[CondApiDoc#cond-let cond-let] 

----
===condt===
by Stuart Sierra<br>
API Overview [CondtApiDoc here]

<pre> Generic case-like macro using template expressions</pre>
Public Variables and Functions:
[CondtApiDoc#condt condt] [CondtApiDoc#econdt econdt] 

----
===core===
by Laurent Petit (and others)<br>
API Overview [CoreApiDoc here]

<pre> Functions/macros variants of the ones that can be found in clojure.core  
(note to other contrib members: feel free to add to this lib)</pre>
Public Variables and Functions:
[CoreApiDoc#-?> -?>] [CoreApiDoc#.?. .?.] [CoreApiDoc#dissoc-in dissoc-in] [CoreApiDoc#new-by-name new-by-name] [CoreApiDoc#seqable? seqable?] 

----
===dataflow===
by Jeffrey Straszheim<br>
API Overview [DataflowApiDoc here]

<pre> A library to support a dataflow model of state</pre>
Public Variables and Functions:
[DataflowApiDoc#add-cell-watcher add-cell-watcher] [DataflowApiDoc#add-cells add-cells] [DataflowApiDoc#build-dataflow build-dataflow] [DataflowApiDoc#build-source-cell build-source-cell] [DataflowApiDoc#build-standard-cell build-standard-cell] [DataflowApiDoc#build-validator-cell build-validator-cell] [DataflowApiDoc#cell cell] [DataflowApiDoc#display-cell display-cell] [DataflowApiDoc#eval-cell eval-cell] [DataflowApiDoc#get-cell get-cell] [DataflowApiDoc#get-cells get-cells] [DataflowApiDoc#get-old-value get-old-value] [DataflowApiDoc#get-source-cells get-source-cells] [DataflowApiDoc#get-value get-value] [DataflowApiDoc#get-value-from-cell get-value-from-cell] [DataflowApiDoc#get-values get-values] [DataflowApiDoc#print-dataflow print-dataflow] [DataflowApiDoc#remove-cells remove-cells] [DataflowApiDoc#source-cell? source-cell?] [DataflowApiDoc#update-values update-values] 

----
===datalog===
by Jeffrey Straszheim<br>
API Overview [DatalogApiDoc here]

<pre> A Clojure implementation of Datalog</pre>
See also: [DatalogOverview]

Public Variables and Functions:
[DatalogApiDoc#build-work-plan build-work-plan] [DatalogApiDoc#run-work-plan run-work-plan] 

Variables and Functions in datalog.database:
[DatalogApiDoc#add-index add-index] [DatalogApiDoc#add-relation add-relation] [DatalogApiDoc#add-tuple add-tuple] [DatalogApiDoc#add-tuples add-tuples] [DatalogApiDoc#any-match? any-match?] [DatalogApiDoc#database-counts database-counts] [DatalogApiDoc#database-merge database-merge] [DatalogApiDoc#database-merge-parallel database-merge-parallel] [DatalogApiDoc#datalog-relation datalog-relation] [DatalogApiDoc#ensure-relation ensure-relation] [DatalogApiDoc#get-relation get-relation] [DatalogApiDoc#make-database make-database] [DatalogApiDoc#merge-relations merge-relations] [DatalogApiDoc#remove-tuple remove-tuple] [DatalogApiDoc#replace-relation replace-relation] [DatalogApiDoc#select select] 

Variables and Functions in datalog.literals:
[DatalogApiDoc#adorned-literal adorned-literal] [DatalogApiDoc#build-atom build-atom] [DatalogApiDoc#build-literal build-literal] [DatalogApiDoc#build-seed-bindings build-seed-bindings] [DatalogApiDoc#delta-literal delta-literal] [DatalogApiDoc#display-literal display-literal] [DatalogApiDoc#get-adorned-bindings get-adorned-bindings] [DatalogApiDoc#get-base-predicate get-base-predicate] [DatalogApiDoc#get-cs-from-vs get-cs-from-vs] [DatalogApiDoc#get-self-bound-cs get-self-bound-cs] [DatalogApiDoc#get-vs-from-cs get-vs-from-cs] [DatalogApiDoc#join-literal join-literal] [DatalogApiDoc#literal-appropriate? literal-appropriate?] [DatalogApiDoc#literal-columns literal-columns] [DatalogApiDoc#literal-magic? literal-magic?] [DatalogApiDoc#literal-predicate literal-predicate] [DatalogApiDoc#literal-vars literal-vars] [DatalogApiDoc#magic-literal magic-literal] [DatalogApiDoc#negated-literal negated-literal] [DatalogApiDoc#negated? negated?] [DatalogApiDoc#negative-vars negative-vars] [DatalogApiDoc#positive-vars positive-vars] [DatalogApiDoc#positive? positive?] [DatalogApiDoc#project-literal project-literal] 

Variables and Functions in datalog.magic:
[DatalogApiDoc#adorn-query adorn-query] [DatalogApiDoc#adorn-rules-set adorn-rules-set] [DatalogApiDoc#build-partial-tuple build-partial-tuple] [DatalogApiDoc#magic-transform magic-transform] [DatalogApiDoc#seed-predicate-for-insertion seed-predicate-for-insertion] [DatalogApiDoc#seed-relation seed-relation] [DatalogApiDoc#seed-rule seed-rule] 

Variables and Functions in datalog.rules:
[DatalogApiDoc#<- <-] [DatalogApiDoc#?- ?-] [DatalogApiDoc#all-predicates all-predicates] [DatalogApiDoc#apply-rule apply-rule] [DatalogApiDoc#compute-sip compute-sip] [DatalogApiDoc#display-query display-query] [DatalogApiDoc#display-rule display-rule] [DatalogApiDoc#is-safe? is-safe?] [DatalogApiDoc#make-rules-set make-rules-set] [DatalogApiDoc#non-base-rules non-base-rules] [DatalogApiDoc#predicate-map predicate-map] [DatalogApiDoc#return-rule-data return-rule-data] [DatalogApiDoc#rules-set rules-set] 

Variables and Functions in datalog.softstrat:
[DatalogApiDoc#build-soft-strat-work-plan build-soft-strat-work-plan] [DatalogApiDoc#get-all-relations get-all-relations] 

Variables and Functions in datalog.util:
[DatalogApiDoc#is-query-var? is-query-var?] [DatalogApiDoc#is-var? is-var?] [DatalogApiDoc#keys-to-vals keys-to-vals] [DatalogApiDoc#map-values map-values] [DatalogApiDoc#preduce preduce] [DatalogApiDoc#reverse-map reverse-map] [DatalogApiDoc#trace-datalog trace-datalog] 

----
===def===
by Stephen C. Gilardi<br>
API Overview [DefApiDoc here]

<pre> def.clj provides variants of def that make including doc strings and 
making private definitions more succinct.</pre>
Public Variables and Functions:
[DefApiDoc#defalias defalias] [DefApiDoc#defhinted defhinted] [DefApiDoc#defmacro- defmacro-] [DefApiDoc#defnk defnk] [DefApiDoc#defonce- defonce-] [DefApiDoc#defstruct- defstruct-] [DefApiDoc#defunbound defunbound] [DefApiDoc#defunbound- defunbound-] [DefApiDoc#defvar defvar] [DefApiDoc#defvar- defvar-] [DefApiDoc#name-with-attributes name-with-attributes] 

----
===duck-streams===
by Stuart Sierra<br>
API Overview [DuckStreamsApiDoc here]

<pre> This file defines "duck-typed" I/O utility functions for Clojure. 
The 'reader' and 'writer' functions will open and return an 
instance of java.io.BufferedReader and java.io.PrintWriter, 
respectively, for a variety of argument types -- filenames as 
strings, URLs, java.io.File's, etc.  'reader' even works on http 
URLs. 
 
Note: this is not really "duck typing" as implemented in languages 
like Ruby.  A better name would have been "do-what-I-mean-streams" 
or "just-give-me-a-stream", but ducks are funnier.</pre>
Public Variables and Functions:
[DuckStreamsApiDoc#_*append-to-writer_* *append-to-writer*] [DuckStreamsApiDoc#append-spit append-spit] [DuckStreamsApiDoc#append-writer append-writer] [DuckStreamsApiDoc#file-str file-str] [DuckStreamsApiDoc#pwd pwd] [DuckStreamsApiDoc#read-lines read-lines] [DuckStreamsApiDoc#reader reader] [DuckStreamsApiDoc#slurp_* slurp*] [DuckStreamsApiDoc#spit spit] [DuckStreamsApiDoc#with-in-reader with-in-reader] [DuckStreamsApiDoc#with-out-append-writer with-out-append-writer] [DuckStreamsApiDoc#with-out-writer with-out-writer] [DuckStreamsApiDoc#write-lines write-lines] [DuckStreamsApiDoc#writer writer] 

----
===error-kit===
by Chris Houser<br>
API Overview [ErrorKitApiDoc here]

<pre> EXPERIMENTAL 
System for defining and using custom errors 
Please contact Chouser if you have any suggestions for better names 
or API adjustments.</pre>
Public Variables and Functions:
[ErrorKitApiDoc#bind-continue bind-continue] [ErrorKitApiDoc#deferror deferror] [ErrorKitApiDoc#do-not-handle do-not-handle] [ErrorKitApiDoc#error error] [ErrorKitApiDoc#handle handle] [ErrorKitApiDoc#raise raise] [ErrorKitApiDoc#raise_* raise*] [ErrorKitApiDoc#throw-msg throw-msg] [ErrorKitApiDoc#with-handler with-handler] 

----
===except===
by Stephen C. Gilardi<br>
API Overview [ExceptApiDoc here]

<pre> Provides functions that make it easy to specify the class and message 
when throwing an Exception or Error. The optional message is formatted 
using clojure/format.</pre>
Public Variables and Functions:
[ExceptApiDoc#throw-arg throw-arg] [ExceptApiDoc#throw-if throw-if] [ExceptApiDoc#throw-if-not throw-if-not] [ExceptApiDoc#throwf throwf] 

----
===fcase===
by Stuart Sierra<br>
API Overview [FcaseApiDoc here]

<pre> This file defines a generic "case" macro called "fcase" which takes 
the equality-testing function as an argument.  It also defines a 
traditional "case" macro that tests using "`=`" and variants that 
test for regular expressions and class membership. 
 
 
Note (December 23, 2008): This library has been supplanted by the 
inclusion of "condp" in clojure.core as of Clojure SVN rev. 1180.</pre>
Public Variables and Functions:
[FcaseApiDoc#case case] [FcaseApiDoc#fcase fcase] [FcaseApiDoc#in-case in-case] [FcaseApiDoc#instance-case instance-case] [FcaseApiDoc#re-case re-case] 

----
===find-namespaces===
by Stuart Sierra<br>
API Overview [FindNamespacesApiDoc here]

<pre> Search for ns declarations in dirs, JARs, or CLASSPATH</pre>
Public Variables and Functions:
[FindNamespacesApiDoc#clojure-source-file? clojure-source-file?] [FindNamespacesApiDoc#clojure-sources-in-jar clojure-sources-in-jar] [FindNamespacesApiDoc#comment? comment?] [FindNamespacesApiDoc#find-clojure-sources-in-dir find-clojure-sources-in-dir] [FindNamespacesApiDoc#find-namespaces-in-dir find-namespaces-in-dir] [FindNamespacesApiDoc#find-namespaces-in-jarfile find-namespaces-in-jarfile] [FindNamespacesApiDoc#find-namespaces-on-classpath find-namespaces-on-classpath] [FindNamespacesApiDoc#find-ns-decls-in-dir find-ns-decls-in-dir] [FindNamespacesApiDoc#find-ns-decls-in-jarfile find-ns-decls-in-jarfile] [FindNamespacesApiDoc#find-ns-decls-on-classpath find-ns-decls-on-classpath] [FindNamespacesApiDoc#ns-decl? ns-decl?] [FindNamespacesApiDoc#read-file-ns-decl read-file-ns-decl] [FindNamespacesApiDoc#read-ns-decl read-ns-decl] [FindNamespacesApiDoc#read-ns-decl-from-jarfile-entry read-ns-decl-from-jarfile-entry] 

----
===fnmap===
by Stuart Sierra<br>
API Overview [FnmapApiDoc here]

<pre> Maps that dispatch get/assoc to user-defined functions. 
 
Note: requires AOT-compilation</pre>
----
===gen-html-docs===
by Craig Andera<br>
API Overview [GenHtmlDocsApiDoc here]

<pre> Generates a single HTML page that contains the documentation for 
one or more Clojure libraries.</pre>
Public Variables and Functions:
[GenHtmlDocsApiDoc#generate-documentation generate-documentation] [GenHtmlDocsApiDoc#generate-documentation-to-file generate-documentation-to-file] 

----
===generic.arithmetic===
by Konrad Hinsen<br>
API Overview [GenericArithmeticApiDoc here]

<pre> Generic arithmetic interface 
This library defines generic versions of + - `*` / as multimethods 
that can be defined for any type. The minimal required  
implementations for a type are binary + and `*` plus unary - and /. 
Everything else is derived from these automatically. Explicit 
binary definitions for - and / can be provided for 
efficiency reasons.</pre>
Public Variables and Functions:
[GenericArithmeticApiDoc#_* *] [GenericArithmeticApiDoc#+ +] [GenericArithmeticApiDoc#- -] [GenericArithmeticApiDoc#/ /] [GenericArithmeticApiDoc#defmethod_* defmethod*] [GenericArithmeticApiDoc#qsym qsym] 

----
===generic.collection===
by Konrad Hinsen<br>
API Overview [GenericCollectionApiDoc here]

<pre> Generic arithmetic interface 
This library defines generic versions of common 
collection-related functions as multimethods that can be 
defined for any type.</pre>
Public Variables and Functions:
[GenericCollectionApiDoc#assoc assoc] [GenericCollectionApiDoc#conj conj] [GenericCollectionApiDoc#dissoc dissoc] [GenericCollectionApiDoc#empty empty] [GenericCollectionApiDoc#get get] [GenericCollectionApiDoc#into into] [GenericCollectionApiDoc#seq seq] 

----
===generic.comparison===
by Konrad Hinsen<br>
API Overview [GenericComparisonApiDoc here]

<pre> Generic comparison interface 
This library defines generic versions of `=` < > <`=` >`=` zero? 
as multimethods that can be defined for any type. Of the 
greater/less-than relations, types must minimally implement >.</pre>
Public Variables and Functions:
[GenericComparisonApiDoc#< <] [GenericComparisonApiDoc#<_= <=] [GenericComparisonApiDoc#_= =] [GenericComparisonApiDoc#> >] [GenericComparisonApiDoc#>_= >=] [GenericComparisonApiDoc#zero? zero?] 

----
===generic.functor===
by Konrad Hinsen<br>
API Overview [GenericFunctorApiDoc here]

<pre> Generic functor interface (fmap)</pre>
Public Variables and Functions:
[GenericFunctorApiDoc#fmap fmap] 

----
===generic.math-functions===
by Konrad Hinsen<br>
API Overview [GenericMathFunctionsApiDoc here]

<pre> Generic math function interface 
This library defines generic versions of common mathematical 
functions such as sqrt or sin as multimethods that can be 
defined for any type.</pre>
Public Variables and Functions:
[GenericMathFunctionsApiDoc#abs abs] [GenericMathFunctionsApiDoc#acos acos] [GenericMathFunctionsApiDoc#approx_= approx=] [GenericMathFunctionsApiDoc#asin asin] [GenericMathFunctionsApiDoc#atan atan] [GenericMathFunctionsApiDoc#atan2 atan2] [GenericMathFunctionsApiDoc#ceil ceil] [GenericMathFunctionsApiDoc#conjugate conjugate] [GenericMathFunctionsApiDoc#cos cos] [GenericMathFunctionsApiDoc#exp exp] [GenericMathFunctionsApiDoc#floor floor] [GenericMathFunctionsApiDoc#log log] [GenericMathFunctionsApiDoc#pow pow] [GenericMathFunctionsApiDoc#rint rint] [GenericMathFunctionsApiDoc#round round] [GenericMathFunctionsApiDoc#sgn sgn] [GenericMathFunctionsApiDoc#sin sin] [GenericMathFunctionsApiDoc#sqr sqr] [GenericMathFunctionsApiDoc#sqrt sqrt] [GenericMathFunctionsApiDoc#tan tan] 

----
===graph===
by Jeffrey Straszheim<br>
API Overview [GraphApiDoc here]

<pre> Basic graph theory algorithms</pre>
Public Variables and Functions:
[GraphApiDoc#add-loops add-loops] [GraphApiDoc#component-graph component-graph] [GraphApiDoc#dependency-list dependency-list] [GraphApiDoc#fixed-point fixed-point] [GraphApiDoc#get-neighbors get-neighbors] [GraphApiDoc#lazy-walk lazy-walk] [GraphApiDoc#post-ordered-nodes post-ordered-nodes] [GraphApiDoc#recursive-component? recursive-component?] [GraphApiDoc#remove-loops remove-loops] [GraphApiDoc#reverse-graph reverse-graph] [GraphApiDoc#scc scc] [GraphApiDoc#self-recursive-sets self-recursive-sets] [GraphApiDoc#stratification-list stratification-list] [GraphApiDoc#transitive-closure transitive-closure] 

----
===greatest-least===
by Vincent Foley<br>
API Overview [GreatestLeastApiDoc here]

<pre> Various functions for finding greatest and least values in a collection</pre>
Public Variables and Functions:
[GreatestLeastApiDoc#all-greatest all-greatest] [GreatestLeastApiDoc#all-greatest-by all-greatest-by] [GreatestLeastApiDoc#all-least all-least] [GreatestLeastApiDoc#all-least-by all-least-by] [GreatestLeastApiDoc#greatest greatest] [GreatestLeastApiDoc#greatest-by greatest-by] [GreatestLeastApiDoc#least least] [GreatestLeastApiDoc#least-by least-by] 

----
===import-static===
by Stuart Sierra<br>
API Overview [ImportStaticApiDoc here]

<pre> Import static Java methods/fields into Clojure</pre>
Public Variables and Functions:
[ImportStaticApiDoc#import-static import-static] 

----
===jar===
by Stuart Sierra<br>
API Overview [JarApiDoc here]

<pre> Utilities for working with Java JAR files</pre>
Public Variables and Functions:
[JarApiDoc#filenames-in-jar filenames-in-jar] [JarApiDoc#jar-file? jar-file?] 

----
===java-utils===
by Stuart Halloway, Stephen C. Gilardi, Shawn Hoover, Perry Trolard<br>
API Overview [JavaUtilsApiDoc here]

<pre> A set of utilties for dealing with Java stuff like files and properties. 
 
Design goals: 
 
(1) Ease-of-use. These APIs should be convenient. Performance is secondary. 
 
(2) Duck typing. I hate having to think about the difference between 
    a string that names a file, and a File. Ditto for a ton of other  
    wrapper classes in the Java world (URL, InternetAddress). With these 
    APIs you should be able to think about domain equivalence, not type 
    equivalence. 
 
(3) No bossiness. I am not marking any of these functions as private 
    the docstrings will tell you the intended usage but do what works for you. 					 
 
Feedback welcome! 
 
If something in this module violates the principle of least surprise, please  
let me (Stu) and the Clojure community know via the mailing list.</pre>
Public Variables and Functions:
[JavaUtilsApiDoc#as-file as-file] [JavaUtilsApiDoc#as-properties as-properties] [JavaUtilsApiDoc#as-str as-str] [JavaUtilsApiDoc#file file] [JavaUtilsApiDoc#get-system-property get-system-property] [JavaUtilsApiDoc#read-properties read-properties] [JavaUtilsApiDoc#relative-path-string relative-path-string] [JavaUtilsApiDoc#set-system-properties set-system-properties] [JavaUtilsApiDoc#with-system-properties with-system-properties] [JavaUtilsApiDoc#write-properties write-properties] 

----
===javadoc.browse===
by Christophe Grand<br>
API Overview [JavadocBrowseApiDoc here]

<pre> Start a web browser from Clojure</pre>
Public Variables and Functions:
[JavadocBrowseApiDoc#open-url-in-browser open-url-in-browser] [JavadocBrowseApiDoc#open-url-in-swing open-url-in-swing] 

----
===json.read===
by Stuart Sierra<br>
API Overview [JsonReadApiDoc here]

<pre> JavaScript Object Notation (JSON) parser 
 
For more information on JSON, see http://www.json.org/ 
 
This library parses data in JSON format.  This is a fairly strict 
implementation of JSON as described at json.org, not a full-fledged 
JavaScript parser.  JavaScript functions and object constructors 
are not supported.  Object field names must be quoted strings; they 
may not be bare symbols. 
 
If you want to convert map keys from strings to keywords, use 
clojure.contrib.walk/keywordize-keys</pre>
See also: [http://www.json.org JSON Home Page]

Public Variables and Functions:
[JsonReadApiDoc#_*json-keyword-keys_* *json-keyword-keys*] [JsonReadApiDoc#read-json read-json] 

----
===json.write===
by Stuart Sierra<br>
API Overview [JsonWriteApiDoc here]

<pre> JavaScript Object Notation (JSON) generator. 
 
This library will generate JSON from the following types: 
 `*` nil 
 `*` all primitives (Boolean, Byte, Short, Integer, Long, Float, Double) 
 `*` String (actually any CharSequence) 
 `*` java.util.Map (including Clojure maps) 
 `*` java.util.Collection (including Clojure vectors, lists, and sets) 
 `*` Java arrays 
 
You can extend this library to handle new types by adding methods to 
print-json. 
 
This library does NOT attempt to preserve round-trip equality between 
JSON and Clojure data types. That is, if you write a JSON string with 
this library, then read it back with clojure.contrib.json.read, you 
won't necessarily get the exact same data structure.  For example, 
Clojure sets are written as JSON arrays, which will be read back as 
Clojure vectors. 
 
If you want indented output, try the clojure-json library at 
http://github.com/danlarkin/clojure-json 
 
This implementation attempts to follow the description of JSON at 
<http://json.org/>.  Maps become JSON objects, all other collections 
become JSON arrays.  JSON object keys are always converted to strings. 
Within strings, all non-ASCII characters are hexadecimal escaped.</pre>
See also: [http://json.org/ JSON Home Page]

Public Variables and Functions:
[JsonWriteApiDoc#json-str json-str] [JsonWriteApiDoc#print-json print-json] 

----
===lazy-seqs===
by Stephen C. Gilardi<br>
API Overview [LazySeqsApiDoc here]

<pre>  
`=``=``=``=` Lazy sequences `=``=``=``=` 
 
 primes - based on the "naive" implemention described in `[`1`]` plus a 
          small "wheel" which eliminates multiples of 2, 3, 5, and 
          7 from consideration by incrementing past them. Also inspired 
          by code from Christophe Grand in `[`2`]`. 
 
 fibs   - all the Fibonacci numbers 
 
 powers-of-2 - all the powers of 2 
 
 `=``=``=``=` Lazy sequence functions `=``=``=``=` 
 
 (rotations, partition-all, shuffle, rand-elt  moved to seq`_`utils.clj) 
 (permutations and combinations moved to combinatorics.clj) 
 
 `[`1`]` http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf 
 `[`2`]` http://clj-me.blogspot.com/2008/06/primes.html</pre>
Public Variables and Functions:
[LazySeqsApiDoc#fibs fibs] [LazySeqsApiDoc#powers-of-2 powers-of-2] [LazySeqsApiDoc#primes primes] 

----
===lazy-xml===
by Chris Houser<br>
API Overview [LazyXmlApiDoc here]

<pre> Functions to parse xml lazily and emit back to text.</pre>
Public Variables and Functions:
[LazyXmlApiDoc#emit emit] [LazyXmlApiDoc#emit-element emit-element] [LazyXmlApiDoc#parse-seq parse-seq] [LazyXmlApiDoc#parse-trim parse-trim] 

----
===macro-utils===
by Konrad Hinsen<br>
API Overview [MacroUtilsApiDoc here]

<pre> Local macros and symbol macros 
 
Local macros are defined by a macrolet form. They are usable only 
inside its body. Symbol macros can be defined globally 
(defsymbolmacro) or locally (symbol-macrolet). A symbol 
macro defines a form that replaces a symbol during macro 
expansion. Function arguments and symbols bound in let 
forms are not subject to symbol macro expansion. 
 
Local macros are most useful in the definition of the expansion 
of another macro, they may be used anywhere. Global symbol 
macros can be used only inside a with-symbol-macros form.</pre>
Public Variables and Functions:
[MacroUtilsApiDoc#defsymbolmacro defsymbolmacro] [MacroUtilsApiDoc#deftemplate deftemplate] [MacroUtilsApiDoc#macrolet macrolet] [MacroUtilsApiDoc#mexpand mexpand] [MacroUtilsApiDoc#mexpand-1 mexpand-1] [MacroUtilsApiDoc#mexpand-all mexpand-all] [MacroUtilsApiDoc#symbol-macrolet symbol-macrolet] [MacroUtilsApiDoc#with-symbol-macros with-symbol-macros] 

----
===macros===
by Konrad Hinsen<br>
API Overview [MacrosApiDoc here]

<pre> Various small macros</pre>
Public Variables and Functions:
[MacrosApiDoc#const const] [MacrosApiDoc#letfn- letfn-] 

----
===map-utils===
by Jason Wolfe, Chris Houser<br>
API Overview [MapUtilsApiDoc here]

<pre> Utilities for operating on Clojure maps.</pre>
Public Variables and Functions:
[MapUtilsApiDoc#deep-merge-with deep-merge-with] [MapUtilsApiDoc#lazy-get lazy-get] [MapUtilsApiDoc#safe-get safe-get] [MapUtilsApiDoc#safe-get-in safe-get-in] 

----
===math===
by Mark Engelberg<br>
API Overview [MathApiDoc here]

<pre> Math functions that deal intelligently with the various 
types in Clojure's numeric tower, as well as math functions 
commonly found in Scheme implementations. 
 
expt - (expt x y) is x to the yth power, returns an exact number 
  if the base is an exact number, and the power is an integer, 
  otherwise returns a double. 
abs - (abs n) is the absolute value of n 
gcd - (gcd m n) returns the greatest common divisor of m and n 
lcm - (lcm m n) returns the least common multiple of m and n 
 
The behavior of the next three functions on doubles is consistent 
with the behavior of the corresponding functions 
in Java's Math library, but on exact numbers, returns an integer. 
 
floor - (floor n) returns the greatest integer less than or equal to n. 
  If n is an exact number, floor returns an integer, 
  otherwise a double. 
ceil - (ceil n) returns the least integer greater than or equal to n. 
  If n is an exact number, ceil returns an integer, 
  otherwise a double. 
round - (round n) rounds to the nearest integer. 
  round always returns an integer.  round rounds up for values 
  exactly in between two integers. 
 
 
sqrt - Implements the sqrt behavior I'm accustomed to from PLT Scheme, 
  specifically, if the input is an exact number, and is a square 
  of an exact number, the output will be exact.  The downside 
  is that for the common case (inexact square root), some extra 
  computation is done to look for an exact square root first. 
  So if you need blazingly fast square root performance, and you 
  know you're just going to need a double result, you're better 
  off calling java's Math/sqrt, or alternatively, you could just 
  convert your input to a double before calling this sqrt function. 
  If Clojure ever gets complex numbers, then this function will 
  need to be updated (so negative inputs yield complex outputs). 
exact-integer-sqrt - Implements a math function from the R6RS Scheme 
  standard.  (exact-integer-sqrt k) where k is a non-negative integer, 
  returns `[`s r`]` where k `=` s^2+r and k < (s+1)^2.  In other words, it 
  returns the floor of the square root and the </pre>
Public Variables and Functions:
[MathApiDoc#abs abs] [MathApiDoc#ceil ceil] [MathApiDoc#exact-integer-sqrt exact-integer-sqrt] [MathApiDoc#expt expt] [MathApiDoc#floor floor] [MathApiDoc#gcd gcd] [MathApiDoc#lcm lcm] [MathApiDoc#round round] [MathApiDoc#sqrt sqrt] 

----
===miglayout===
by Stephen C. Gilardi<br>
API Overview [MiglayoutApiDoc here]

<pre> Clojure support for the MiGLayout layout manager 
http://www.miglayout.com/ 
 
Example: 
 
  (use '`[`clojure.contrib.miglayout.test :as mlt :only ()`]`) 
  (dotimes `[`i 5`]` (mlt/run-test i))</pre>
Public Variables and Functions:
[MiglayoutApiDoc#components components] [MiglayoutApiDoc#miglayout miglayout] 

Variables and Functions in miglayout.example:
[MiglayoutApiDoc#converter-ui converter-ui] [MiglayoutApiDoc#fahrenheit fahrenheit] [MiglayoutApiDoc#main main] 

Variables and Functions in miglayout.internal:
[MiglayoutApiDoc#add-components add-components] [MiglayoutApiDoc#component? component?] [MiglayoutApiDoc#constraint? constraint?] [MiglayoutApiDoc#do-layout do-layout] [MiglayoutApiDoc#format-constraint format-constraint] [MiglayoutApiDoc#format-constraints format-constraints] [MiglayoutApiDoc#get-components get-components] [MiglayoutApiDoc#parse-component-constraint parse-component-constraint] [MiglayoutApiDoc#parse-item-constraints parse-item-constraints] 

Variables and Functions in miglayout.test:
[MiglayoutApiDoc#label label] [MiglayoutApiDoc#sep sep] [MiglayoutApiDoc#text-field text-field] 

----
===mmap===
by Chris Houser<br>
API Overview [MmapApiDoc here]

<pre> Functions for memory-mapping files, plus some functions that use a 
mmaped file for "normal" activies -- slurp, load-file, etc.</pre>
Public Variables and Functions:
[MmapApiDoc#buffer-stream buffer-stream] [MmapApiDoc#mmap mmap] [MmapApiDoc#slurp slurp] 

----
===monads===
by Konrad Hinsen<br>
API Overview [MonadsApiDoc here]

<pre> This library contains the most commonly used monads as well 
as macros for defining and using monads and useful monadic 
functions.</pre>
See also: [http://onclojure.com/2009/03/05/a-monad-tutorial-for-clojure-programmers-part-1/ Monad tutorial part 1], [http://onclojure.com/2009/03/06/a-monad-tutorial-for-clojure-programmers-part-2/ Monad tutorial part 2], [http://onclojure.com/2009/03/23/a-monad-tutorial-for-clojure-programmers-part-3/ Monad tutorial part 3], [http://onclojure.com/2009/04/24/a-monad-tutorial-for-clojure-programmers-part-4/ Monad tutorial part 4], [http://intensivesystems.net/tutorials/monads_101.html Monads in Clojure part 1], [http://intensivesystems.net/tutorials/monads_201.html Monads in Clojure part 2]

Public Variables and Functions:
[MonadsApiDoc#call-cc call-cc] [MonadsApiDoc#cont-m cont-m] [MonadsApiDoc#defmonad defmonad] [MonadsApiDoc#defmonadfn defmonadfn] [MonadsApiDoc#domonad domonad] [MonadsApiDoc#identity-m identity-m] [MonadsApiDoc#m-chain m-chain] [MonadsApiDoc#m-fmap m-fmap] [MonadsApiDoc#m-join m-join] [MonadsApiDoc#m-lift m-lift] [MonadsApiDoc#m-map m-map] [MonadsApiDoc#m-reduce m-reduce] [MonadsApiDoc#m-seq m-seq] [MonadsApiDoc#m-when m-when] [MonadsApiDoc#m-when-not m-when-not] [MonadsApiDoc#maybe-m maybe-m] [MonadsApiDoc#maybe-t maybe-t] [MonadsApiDoc#monad monad] [MonadsApiDoc#monad-transformer monad-transformer] [MonadsApiDoc#run-cont run-cont] [MonadsApiDoc#sequence-m sequence-m] [MonadsApiDoc#sequence-t sequence-t] [MonadsApiDoc#set-m set-m] [MonadsApiDoc#state-m state-m] [MonadsApiDoc#state-t state-t] [MonadsApiDoc#with-monad with-monad] [MonadsApiDoc#writer-m writer-m] 

----
===ns-utils===
by Stephen C. Gilardi<br>
API Overview [NsUtilsApiDoc here]

<pre> Namespace utilities</pre>
Public Variables and Functions:
[NsUtilsApiDoc#dir dir] [NsUtilsApiDoc#docs docs] [NsUtilsApiDoc#get-ns get-ns] [NsUtilsApiDoc#ns-vars ns-vars] [NsUtilsApiDoc#print-dir print-dir] [NsUtilsApiDoc#print-docs print-docs] [NsUtilsApiDoc#vars vars] 

----
===pprint===
by Tom Faulhaber<br>
API Overview [PprintApiDoc here]

<pre> This module comprises two elements: 
1) A pretty printer for Clojure data structures, implemented in the function "pprint" 
2) A Common Lisp compatible format function, implemented as "cl-format" because 
   Clojure is using the name "format" for its own format. 
 
Complete documentation is available on the wiki at the contrib google code site.</pre>
See also: [PrettyPrinting Documentation for the pretty printer], [CommonLispFormat Documentation for Common Lisp format function]

Public Variables and Functions:
[PprintApiDoc#_*code-dispatch_* *code-dispatch*] [PprintApiDoc#_*print-circle_* *print-circle*] [PprintApiDoc#_*print-lines_* *print-lines*] [PprintApiDoc#_*print-miser-width_* *print-miser-width*] [PprintApiDoc#_*print-pprint-dispatch_* *print-pprint-dispatch*] [PprintApiDoc#_*print-pretty_* *print-pretty*] [PprintApiDoc#_*print-right-margin_* *print-right-margin*] [PprintApiDoc#_*print-shared_* *print-shared*] [PprintApiDoc#_*print-suppress-namespaces_* *print-suppress-namespaces*] [PprintApiDoc#_*simple-dispatch_* *simple-dispatch*] [PprintApiDoc#cl-format cl-format] [PprintApiDoc#compile-format compile-format] [PprintApiDoc#formatter formatter] [PprintApiDoc#formatter-out formatter-out] [PprintApiDoc#fresh-line fresh-line] [PprintApiDoc#pp pp] [PprintApiDoc#pprint pprint] [PprintApiDoc#pprint-indent pprint-indent] [PprintApiDoc#pprint-logical-block pprint-logical-block] [PprintApiDoc#pprint-newline pprint-newline] [PprintApiDoc#pprint-tab pprint-tab] [PprintApiDoc#set-pprint-dispatch set-pprint-dispatch] [PprintApiDoc#use-method use-method] [PprintApiDoc#with-pprint-dispatch with-pprint-dispatch] [PprintApiDoc#write write] [PprintApiDoc#write-out write-out] 

Variables and Functions in pprint.examples.json:
[PprintApiDoc#dispatch-json dispatch-json] [PprintApiDoc#json-str json-str] [PprintApiDoc#print-json print-json] 

Variables and Functions in pprint.examples.xml:
[PprintApiDoc#_*html-compatible_* *html-compatible*] [PprintApiDoc#_*prxml-indent_* *prxml-indent*] [PprintApiDoc#prxml prxml] 

----
===probabilities.finite-distributions===
by Konrad Hinsen<br>
API Overview [ProbabilitiesFiniteDistributionsApiDoc here]

<pre> Finite probability distributions 
This library defines a monad for combining finite probability 
distributions.</pre>
Public Variables and Functions:
[ProbabilitiesFiniteDistributionsApiDoc#certainly certainly] [ProbabilitiesFiniteDistributionsApiDoc#choose choose] [ProbabilitiesFiniteDistributionsApiDoc#cond-dist-m cond-dist-m] [ProbabilitiesFiniteDistributionsApiDoc#cond-prob cond-prob] [ProbabilitiesFiniteDistributionsApiDoc#dist-m dist-m] [ProbabilitiesFiniteDistributionsApiDoc#join-with join-with] [ProbabilitiesFiniteDistributionsApiDoc#make-distribution make-distribution] [ProbabilitiesFiniteDistributionsApiDoc#normalize normalize] [ProbabilitiesFiniteDistributionsApiDoc#prob prob] [ProbabilitiesFiniteDistributionsApiDoc#uniform uniform] [ProbabilitiesFiniteDistributionsApiDoc#zipf zipf] 

----
===probabilities.monte-carlo===
by Konrad Hinsen<br>
API Overview [ProbabilitiesMonteCarloApiDoc here]

<pre> Monte-Carlo method support 
 
Monte-Carlo methods transform an input random number stream 
(usually having a continuous uniform distribution in the 
interval `[`0, 1)) into a random number stream whose distribution 
satisfies certain conditions (usually the expectation value 
is equal to some desired quantity). They are thus 
transformations from one probability distribution to another one. 
 
This library represents a Monte-Carlo method by a function that 
takes as input the state of a random number stream with 
uniform distribution (see 
clojure.contrib.probabilities.random-numbers) and returns a 
vector containing one sample value of the desired output 
distribution and the final state of the input random number 
stream. Such functions are state monad values and can be 
composed using operations defined in clojure.contrib.monads.</pre>
Public Variables and Functions:
[ProbabilitiesMonteCarloApiDoc#discrete discrete] [ProbabilitiesMonteCarloApiDoc#exponential exponential] [ProbabilitiesMonteCarloApiDoc#lognormal lognormal] [ProbabilitiesMonteCarloApiDoc#n-sphere n-sphere] [ProbabilitiesMonteCarloApiDoc#normal normal] [ProbabilitiesMonteCarloApiDoc#normal-box-muller normal-box-muller] [ProbabilitiesMonteCarloApiDoc#random-stream random-stream] [ProbabilitiesMonteCarloApiDoc#reject reject] [ProbabilitiesMonteCarloApiDoc#sample sample] [ProbabilitiesMonteCarloApiDoc#sample-mean sample-mean] [ProbabilitiesMonteCarloApiDoc#sample-mean-variance sample-mean-variance] [ProbabilitiesMonteCarloApiDoc#sample-reduce sample-reduce] [ProbabilitiesMonteCarloApiDoc#sample-sum sample-sum] 

----
===probabilities.random-numbers===
by Konrad Hinsen<br>
API Overview [ProbabilitiesRandomNumbersApiDoc here]

<pre> Random number streams 
 
This library provides random number generators with a common 
stream interface. They all produce pseudo-random numbers that are 
uniformly distributed in the interval `[`0, 1), i.e. 0 is a 
possible value but 1 isn't. For transformations to other 
distributions, see clojure.contrib.probabilities.monte-carlo. 
 
At the moment, the only generator provided is a rather simple 
linear congruential generator.</pre>
Public Variables and Functions:
[ProbabilitiesRandomNumbersApiDoc#lcg lcg] [ProbabilitiesRandomNumbersApiDoc#rand-stream rand-stream] 

----
===profile===
by Stuart Sierra<br>
API Overview [ProfileApiDoc here]

<pre> Simple code profiling & timing measurement. 
 
Wrap any section of code in the prof macro, giving it a name, like this: 
 
       (defn my-function `[`x y`]` 
         (let `[`sum (prof :addition (+ x y)) 
               product (prof :multiplication (`*` x y))`]` 
           `[`sum product`]`)) 
 
The run your code in the profile macro, like this: 
 
       (profile (dotimes `[`i 10000`]` (my-function 3 4))) 
 
Which prints a report for each named section of code: 
 
          Name      mean       min       max     count       sum 
      addition       265         0     37000     10000   2655000 
multiplication       274         0     53000     10000   2747000 
 
Times are measured in nanoseconds, to the maximum precision available 
under the JVM.  See the function documentation for more details.</pre>
Public Variables and Functions:
[ProfileApiDoc#_*enable-profiling_* *enable-profiling*] [ProfileApiDoc#print-summary print-summary] [ProfileApiDoc#prof prof] [ProfileApiDoc#profile profile] [ProfileApiDoc#summarize summarize] [ProfileApiDoc#with-profile-data with-profile-data] 

----
===prxml===
by Stuart Sierra<br>
API Overview [PrxmlApiDoc here]

<pre> Compact syntax for generating XML. See the documentation of "prxml"  
for details.</pre>
Public Variables and Functions:
[PrxmlApiDoc#_*html-compatible_* *html-compatible*] [PrxmlApiDoc#_*prxml-indent_* *prxml-indent*] [PrxmlApiDoc#prxml prxml] 

----
===repl-ln===
by Stephen C. Gilardi<br>
API Overview [ReplLnApiDoc here]

<pre> A repl with that provides support for lines and line numbers in the 
input stream.</pre>
Public Variables and Functions:
[ReplLnApiDoc#print-repl-info print-repl-info] [ReplLnApiDoc#repl repl] [ReplLnApiDoc#repl-info repl-info] [ReplLnApiDoc#repl-prompt repl-prompt] [ReplLnApiDoc#set-repl-name set-repl-name] [ReplLnApiDoc#set-repl-prompt set-repl-prompt] [ReplLnApiDoc#stream-repl stream-repl] 

----
===repl-utils===
by Chris Houser, Christophe Grand, Stephen Gilardi<br>
API Overview [ReplUtilsApiDoc here]

<pre> Utilities meant to be used interactively at the REPL</pre>
Public Variables and Functions:
[ReplUtilsApiDoc#_*local-javadocs_* *local-javadocs*] [ReplUtilsApiDoc#_*remote-javadocs_* *remote-javadocs*] [ReplUtilsApiDoc#add-break-thread! add-break-thread!] [ReplUtilsApiDoc#add-local-javadoc add-local-javadoc] [ReplUtilsApiDoc#add-remote-javadoc add-remote-javadoc] [ReplUtilsApiDoc#break-threads break-threads] [ReplUtilsApiDoc#expression-info expression-info] [ReplUtilsApiDoc#find-javadoc-url find-javadoc-url] [ReplUtilsApiDoc#get-source get-source] [ReplUtilsApiDoc#javadoc javadoc] [ReplUtilsApiDoc#run run] [ReplUtilsApiDoc#run_* run*] [ReplUtilsApiDoc#show show] [ReplUtilsApiDoc#source source] [ReplUtilsApiDoc#start-handling-break start-handling-break] 

----
===seq-utils===
by Stuart Sierra (and others)<br>
API Overview [SeqUtilsApiDoc here]

<pre> Sequence utilities for Clojure</pre>
Public Variables and Functions:
[SeqUtilsApiDoc#find-first find-first] [SeqUtilsApiDoc#flatten flatten] [SeqUtilsApiDoc#frequencies frequencies] [SeqUtilsApiDoc#group-by group-by] [SeqUtilsApiDoc#includes? includes?] [SeqUtilsApiDoc#indexed indexed] [SeqUtilsApiDoc#partition-all partition-all] [SeqUtilsApiDoc#partition-by partition-by] [SeqUtilsApiDoc#rand-elt rand-elt] [SeqUtilsApiDoc#rec-cat rec-cat] [SeqUtilsApiDoc#rec-seq rec-seq] [SeqUtilsApiDoc#reductions reductions] [SeqUtilsApiDoc#rotations rotations] [SeqUtilsApiDoc#separate separate] [SeqUtilsApiDoc#seq-on seq-on] [SeqUtilsApiDoc#shuffle shuffle] 

----
===server-socket===
by Craig McDaniel<br>
API Overview [ServerSocketApiDoc here]

<pre> Server socket library - includes REPL on socket</pre>
Public Variables and Functions:
[ServerSocketApiDoc#create-repl-server create-repl-server] [ServerSocketApiDoc#create-server create-server] 

----
===set===
by Jason Wolfe<br>
API Overview [SetApiDoc here]

<pre> Clojure functions for operating on sets (supplemental to clojure.set)</pre>
Public Variables and Functions:
[SetApiDoc#proper-subset? proper-subset?] [SetApiDoc#proper-superset? proper-superset?] [SetApiDoc#subset? subset?] [SetApiDoc#superset? superset?] 

----
===shell-out===
by Chris Houser<br>
API Overview [ShellOutApiDoc here]

<pre> Conveniently launch a sub-process providing to its stdin and 
collecting its stdout</pre>
Public Variables and Functions:
[ShellOutApiDoc#sh sh] 

----
===singleton===
by Stuart Sierra<br>
API Overview [SingletonApiDoc here]

<pre> Singleton functions</pre>
Public Variables and Functions:
[SingletonApiDoc#global-singleton global-singleton] [SingletonApiDoc#per-thread-singleton per-thread-singleton] 

----
===sql===
by Stephen C. Gilardi<br>
API Overview [SqlApiDoc here]

<pre> A Clojure interface to sql databases via jdbc 
 
See clojure.contrib.sql.test for an example</pre>
See also: [http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/sql/test.clj Example code]

Public Variables and Functions:
[SqlApiDoc#connection connection] [SqlApiDoc#create-table create-table] [SqlApiDoc#delete-rows delete-rows] [SqlApiDoc#do-commands do-commands] [SqlApiDoc#do-prepared do-prepared] [SqlApiDoc#drop-table drop-table] [SqlApiDoc#find-connection find-connection] [SqlApiDoc#insert-records insert-records] [SqlApiDoc#insert-rows insert-rows] [SqlApiDoc#insert-values insert-values] [SqlApiDoc#is-rollback-only is-rollback-only] [SqlApiDoc#set-rollback-only set-rollback-only] [SqlApiDoc#transaction transaction] [SqlApiDoc#update-or-insert-values update-or-insert-values] [SqlApiDoc#update-values update-values] [SqlApiDoc#with-connection with-connection] [SqlApiDoc#with-query-results with-query-results] 

Variables and Functions in sql.internal:
[SqlApiDoc#connection_* connection*] [SqlApiDoc#find-connection_* find-connection*] [SqlApiDoc#get-connection get-connection] [SqlApiDoc#print-sql-exception print-sql-exception] [SqlApiDoc#print-sql-exception-chain print-sql-exception-chain] [SqlApiDoc#print-update-counts print-update-counts] [SqlApiDoc#rollback rollback] [SqlApiDoc#throw-rollback throw-rollback] [SqlApiDoc#transaction_* transaction*] [SqlApiDoc#with-connection_* with-connection*] [SqlApiDoc#with-query-results_* with-query-results*] 

Variables and Functions in sql.test:
[SqlApiDoc#create-fruit create-fruit] [SqlApiDoc#db-batchupdate-exception db-batchupdate-exception] [SqlApiDoc#db-exception db-exception] [SqlApiDoc#db-get-tables db-get-tables] [SqlApiDoc#db-grade-a db-grade-a] [SqlApiDoc#db-grade-range db-grade-range] [SqlApiDoc#db-read db-read] [SqlApiDoc#db-read-all db-read-all] [SqlApiDoc#db-rollback db-rollback] [SqlApiDoc#db-sql-exception db-sql-exception] [SqlApiDoc#db-update db-update] [SqlApiDoc#db-update-appearance-cost db-update-appearance-cost] [SqlApiDoc#db-update-or-insert db-update-or-insert] [SqlApiDoc#db-write db-write] [SqlApiDoc#drop-fruit drop-fruit] [SqlApiDoc#insert-records-fruit insert-records-fruit] [SqlApiDoc#insert-rows-fruit insert-rows-fruit] [SqlApiDoc#insert-values-fruit insert-values-fruit] 

----
===stacktrace===
by Stuart Sierra<br>
API Overview [StacktraceApiDoc here]

<pre> Print Clojure-centric stack traces</pre>
Public Variables and Functions:
[StacktraceApiDoc#e e] [StacktraceApiDoc#print-cause-trace print-cause-trace] [StacktraceApiDoc#print-stack-trace print-stack-trace] [StacktraceApiDoc#print-throwable print-throwable] [StacktraceApiDoc#print-trace-element print-trace-element] [StacktraceApiDoc#root-cause root-cause] 

----
===str-utils===
by Stuart Sierra<br>
API Overview [StrUtilsApiDoc here]

<pre> String utilities for Clojure</pre>
Public Variables and Functions:
[StrUtilsApiDoc#chomp chomp] [StrUtilsApiDoc#chop chop] [StrUtilsApiDoc#re-gsub re-gsub] [StrUtilsApiDoc#re-partition re-partition] [StrUtilsApiDoc#re-split re-split] [StrUtilsApiDoc#re-sub re-sub] [StrUtilsApiDoc#str-join str-join] 

----
===str-utils2===
by Stuart Sierra<br>
API Overview [StrUtils2ApiDoc here]

<pre> This is a library of string manipulation functions.  It 
is intented as a replacement for clojure.contrib.str-utils. 
 
You cannot (use 'clojure.contrib.str-utils2) because it defines 
functions with the same names as functions in clojure.core. 
Instead, do (require '`[`clojure.contrib.str-utils2 :as s`]`)  
or something similar. 
 
Goals: 
  1. Be functional 
  2. String argument first, to work with -> 
  3. Performance linear in string length 
 
Some ideas are borrowed from 
http://github.com/francoisdevlin/devlinsf-clojure-utils/</pre>
Public Variables and Functions:
[StrUtils2ApiDoc#blank? blank?] [StrUtils2ApiDoc#butlast butlast] [StrUtils2ApiDoc#dochars dochars] [StrUtils2ApiDoc#escape escape] [StrUtils2ApiDoc#replace replace] [StrUtils2ApiDoc#replace-first replace-first] [StrUtils2ApiDoc#tail tail] [StrUtils2ApiDoc#take take] 

----
===stream-utils===
by Konrad Hinsen<br>
API Overview [StreamUtilsApiDoc here]

<pre> Functions for setting up computational pipelines via data streams. 
 
NOTE: This library is experimental. It may change significantly 
      with future release. 
 
This library defines: 
- an abstract stream type, whose interface consists of the 
  multimethod stream-next 
- a macro for implementing streams 
- implementations of stream for 
  1) Clojure sequences, and vectors 
  2) nil, representing an empty stream 
- tools for writing stream transformers, including the 
  monad stream-m 
- various utility functions for working with streams 
 
Streams are building blocks in the construction of computational 
pipelines. A stream is represented by its current state plus 
a function that takes a stream state and obtains the next item 
in the stream as well as the new stream state. The state is 
implemented as a Java class or a Clojure type (as defined by the 
function clojure.core/type), and the function is provided as an 
implementation of the multimethod stream-next for this class or type. 
 
While setting up pipelines using this mechanism is somewhat more 
cumbersome than using Clojure's lazy seq mechanisms, there are a 
few advantages: 
- The state of a stream can be stored in any Clojure data structure, 
  and the stream can be re-generated from it any number of times. 
  Any number of states can be stored this way. 
- The elements of the stream are never cached, so keeping a reference 
  to a stream state does not incur an uncontrollable memory penalty. 
 
Note that the stream mechanism is thread-safe as long as the 
concrete stream implementations do not use any mutable state. 
 
Stream transformers take any number of input streams and produce one 
output stream. They are typically written using the stream-m 
monad. In the definition of a stream transformer, (pick s) returns 
the next value of stream argument s, whereas pick-all returns the 
next value of all stream arguments in the form of a vector.</pre>
Public Variables and Functions:
[StreamUtilsApiDoc#defst defst] [StreamUtilsApiDoc#defstream defstream] [StreamUtilsApiDoc#pick pick] [StreamUtilsApiDoc#pick-all pick-all] [StreamUtilsApiDoc#stream-drop stream-drop] [StreamUtilsApiDoc#stream-filter stream-filter] [StreamUtilsApiDoc#stream-flatten stream-flatten] [StreamUtilsApiDoc#stream-m stream-m] [StreamUtilsApiDoc#stream-map stream-map] [StreamUtilsApiDoc#stream-next stream-next] [StreamUtilsApiDoc#stream-seq stream-seq] [StreamUtilsApiDoc#stream-type stream-type] 

----
===swing-utils===
API Overview [SwingUtilsApiDoc here]

Public Variables and Functions:
[SwingUtilsApiDoc#add-action-listener add-action-listener] [SwingUtilsApiDoc#add-key-typed-listener add-key-typed-listener] 

----
===template===
by Stuart Sierra<br>
API Overview [TemplateApiDoc here]

<pre> Anonymous functions that pre-evaluate sub-expressions 
 
This file defines macros for using template expressions.  These are 
useful for writing macros. 
 
A template is an expression containing "holes" represented by the 
symbols `_`1, `_`2, `_`3, and so on.  ("`_`" is a synonym for "`_`1".) 
 
The "template" macro is similar to #().  It returns an anonymous 
function containing the body of the template.  Unlike #() or "fn", 
however, any expressions that do not have any holes will be 
evaluated only once, at the time the function is created, not every 
time the function is called. 
 
Examples: 
 
Assume we have some big, slow calculation. 
  (defn think-hard `[``]` 
    (Thread/sleep 1000) 
    1000) 
 
With #(), think-hard gets called every time. 
  (time (doall (map #(+ % (think-hard)) 
                    (range 5)))) 
  `=`> "Elapsed time: 5001.33455 msecs" 
  `=`> (1000 1001 1002 1003 1004) 
 
With a template, think-hard only gets called once. 
  (time (doall (map (template (+ `_` (think-hard))) 
                    (range 5)))) 
  `=`> "Elapsed time: 1000.907326 msecs" 
  `=`> (1000 1001 1002 1003 1004) 
 
There is also the do-template macro, which works differently.  It 
calls the same template multiple times, filling in values, and puts 
it all inside a "do" block.  It will split up the values based on 
the number of holes in the template. 
 
  (do-template (foo `_`1 `_`2) :a :b :c :d) 
  expands to: (do (foo :a :b) (foo :c :d)) 
 
  (do-template (foo `_`1 `_`2 `_`3) 10 11 12 13 14 15) 
  expands to: (foo 10 11 12) (foo 13 14 15)</pre>
Public Variables and Functions:
[TemplateApiDoc#apply-template apply-template] [TemplateApiDoc#do-template do-template] [TemplateApiDoc#find-holes find-holes] [TemplateApiDoc#find-pure-exprs find-pure-exprs] [TemplateApiDoc#find-symbols find-symbols] [TemplateApiDoc#flatten-map flatten-map] [TemplateApiDoc#template template] [TemplateApiDoc#template? template?] 

----
===test-is===
by Stuart Sierra, with contributions and suggestions by 
Chas Emerick, Allen Rohner, and Stuart Halloway<br>
API Overview [TestIsApiDoc here]

<pre> Inspired by many Common Lisp test frameworks and clojure/test, 
this file is a Clojure test framework. 
 
ASSERTIONS 
 
The core of the library is the "is" macro, which lets you make 
assertions of any arbitrary expression: 
 
(is (`=` 4 (+ 2 2))) 
(is (instance? Integer 256)) 
(is (.startsWith "abcde" "ab")) 
 
You can type an "is" expression directly at the REPL, which will 
print a message if it fails. 
 
    user> (is (`=` 5 (+ 2 2))) 
 
    FAIL in  (:1) 
    expected: (`=` 5 (+ 2 2)) 
      actual: (not (`=` 5 4)) 
    false 
 
The "expected:" line shows you the original expression, and the 
"actual:" shows you what actually happened.  In this case, it 
shows that (+ 2 2) returned 4, which is not `=` to 5.  Finally, the 
"false" on the last line is the value returned from the 
expression.  The "is" macro always returns the result of the 
inner expression. 
 
There are two special assertions for testing exceptions.  The 
"(is (thrown? c ...))" form tests if an exception of class c is 
thrown: 
 
(is (thrown? ArithmeticException (/ 1 0)))  
 
"(is (thrown-with-msg? c re ...))" does the same thing and also 
tests that the message on the exception matches the regular 
expression re: 
 
(is (thrown-with-msg? ArithmeticException #"Divide by zero" 
                      (/ 1 0))) 
 
DOCUMENTING TESTS 
 
"is" takes an optional second argument, a string describing the 
assertion.  This message will be included in the error report. 
 
(is (`=` 5 (+ 2 2)) "Crazy arithmetic") 
 
In addition, you can document groups of assertions with the 
"testing" macro, which takes a string followed by any number of 
assertions.  The string will be included in failure reports. 
Calls to "testing" may be nested, and all of the strings will be 
joined together with spaces in the final report, in a style 
similar to RSpec <http://rspec.info/> 
 
(testing "Arithmetic" 
  (testing "with positive integers" 
    (is (`=` 4 (+ 2 2))) 
    (is (`=` 7 (+ 3 4)))) 
  (testing "with negative integers" 
    (is (`=` -4 (+ -2 -2))) 
    (is (`=` -1 (+ 3 -4))))) 
 
Note that, unlike RSpec, the "testing" macro may only be used 
INSIDE a "deftest" or "with-test" form (see below). 
 
 
DEFINING TESTS 
 
There are two ways to define tests.  The "with-test" macro takes 
a defn or def form as its first argument, followed by any number 
of assertions.  The tests will be stored as metadata on the 
definition. 
 
(with-test 
    (defn my-function `[`x y`]` 
      (+ x y)) 
  (is (`=` 4 (my-function 2 2))) 
  (is (`=` 7 (my-function 3 4)))) 
 
As of Clojure SVN rev. 1221, this does not work with defmacro. 
See http://code.google.com/p/clojure/issues/detail?id`=`51 
 
The other way lets you define tests separately from the rest of 
your code, even in a different namespace: 
 
(deftest addition 
  (is (`=` 4 (+ 2 2))) 
  (is (`=` 7 (+ 3 4)))) 
 
(deftest subtraction 
  (is (`=` 1 (- 4 3))) 
  (is (`=` 3 (- 7 4)))) 
 
This creates functions named "addition" and "subtraction", which 
can be called like any other function.  Therefore, tests can be 
grouped and composed, in a style similar to the test framework in 
Peter Seibel's "Practical Common Lisp" 
<http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html> 
 
(deftest arithmetic 
  (addition) 
  (subtraction)) 
 
The names of the nested tests will be joined in a list, like 
"(arithmetic addition)", in failure reports.  You can use nested 
tests to set up a context shared by several tests. 
 
 
RUNNING TESTS 
 
Run tests with the function "(run-tests namespaces...)": 
 
(run-tests 'your.namespace 'some.other.namespace) 
 
If you don't specify any namespaces, the current namespace is 
used.  To run all tests in all namespaces, use "(run-all-tests)". 
 
By default, these functions will search for all tests defined in 
a namespace and run them in an undefined order.  However, if you 
are composing tests, as in the "arithmetic" example above, you 
probably do not want the "addition" and "subtraction" tests run 
separately.  In that case, you must define a special function 
named "test-ns-hook" that runs your tests in the correct order: 
 
(defn test-ns-hook `[``]` 
  (arithmetic)) 
 
 
OMITTING TESTS FROM PRODUCTION CODE 
 
You can bind the variable "`*`load-tests`*`" to false when loading or 
compiling code in production.  This will prevent any tests from 
being created by "with-test" or "deftest". 
 
 
FIXTURES (new) 
 
Fixtures allow you to run code before and after tests, to set up 
the context in which tests should be run. 
 
A fixture is just a function that calls another function passed as 
an argument.  It looks like this: 
 
(defn my-fixture `[`f`]` 
   Perform setup, establish bindings, whatever. 
  (f)  Then call the function we were passed. 
   Tear-down / clean-up code here. 
 ) 
 
Fixtures are attached to namespaces in one of two ways.  "each" 
fixtures are run repeatedly, once for each test function created 
with "deftest" or "with-test".  "each" fixtures are useful for 
establishing a consistent before/after state for each test, like 
clearing out database tables. 
 
"each" fixtures can be attached to the current namespace like this: 
(use-fixtures :each fixture1 fixture2 ...) 
The fixture1, fixture2 are just functions like the example above. 
They can also be anonymous functions, like this: 
(use-fixtures :each (fn `[`f`]` setup... (f) cleanup...)) 
 
The other kind of fixture, a "once" fixture, is only run once, 
around ALL the tests in the namespace.  "once" fixtures are useful 
for tasks that only need to be performed once, like establishing 
database connections, or for time-consuming tasks. 
 
Attach "once" fixtures to the current namespace like this: 
(use-fixtures :once fixture1 fixture2 ...) 
 
 
SAVING TEST OUTPUT TO A FILE 
 
All the test reporting functions write to the var `*`test-out`*`.  By 
default, this is the same as `*`out`*`, but you can rebind it to any 
PrintWriter.  For example, it could be a file opened with 
clojure.contrib.duck-streams/writer. 
 
 
EXTENDING TEST-IS (ADVANCED) 
 
You can extend the behavior of the "is" macro by defining new 
methods for the "assert-expr" multimethod.  These methods are 
called during expansion of the "is" macro, so they should return 
quoted forms to be evaluated. 
 
You can plug in your own test-reporting framework by rebinding 
the "report" function: (report event) 
 
The 'event' argument is a map.  It will always have a :type key, 
whose value will be a keyword signaling the type of event being 
reported.  Standard events with :type value of :pass, :fail, and 
:error are called when an assertion passes, fails, and throws an 
exception, respectively.  In that case, the event will also have 
the following keys: 
 
  :expected   The form that was expected to be true 
  :actual     A form representing what actually occurred 
  :message    The string message given as an argument to 'is' 
 
The "testing" strings will be a list in "`*`testing-contexts`*`", and 
the vars being tested will be a list in "`*`testing-vars`*`". 
 
Your "report" function should wrap any printing calls in the 
"with-test-out" macro, which rebinds `*`out`*` to the current value 
of `*`test-out`*`. 
 
For additional event types, see the examples in the code.</pre>
Public Variables and Functions:
[TestIsApiDoc#_*load-tests_* *load-tests*] [TestIsApiDoc#_*stack-trace-depth_* *stack-trace-depth*] [TestIsApiDoc#are are] [TestIsApiDoc#assert-any assert-any] [TestIsApiDoc#assert-predicate assert-predicate] [TestIsApiDoc#compose-fixtures compose-fixtures] [TestIsApiDoc#deftest deftest] [TestIsApiDoc#deftest- deftest-] [TestIsApiDoc#file-position file-position] [TestIsApiDoc#function? function?] [TestIsApiDoc#get-possibly-unbound-var get-possibly-unbound-var] [TestIsApiDoc#inc-report-counter inc-report-counter] [TestIsApiDoc#is is] [TestIsApiDoc#join-fixtures join-fixtures] [TestIsApiDoc#report report] [TestIsApiDoc#run-all-tests run-all-tests] [TestIsApiDoc#run-tests run-tests] [TestIsApiDoc#set-test set-test] [TestIsApiDoc#test-all-vars test-all-vars] [TestIsApiDoc#test-ns test-ns] [TestIsApiDoc#test-var test-var] [TestIsApiDoc#testing testing] [TestIsApiDoc#testing-contexts-str testing-contexts-str] [TestIsApiDoc#testing-vars-str testing-vars-str] [TestIsApiDoc#try-expr try-expr] [TestIsApiDoc#with-test with-test] [TestIsApiDoc#with-test-out with-test-out] 

Variables and Functions in test-is.tap:
[TestIsApiDoc#print-tap-diagnostic print-tap-diagnostic] [TestIsApiDoc#print-tap-fail print-tap-fail] [TestIsApiDoc#print-tap-pass print-tap-pass] [TestIsApiDoc#print-tap-plan print-tap-plan] [TestIsApiDoc#with-tap-output with-tap-output] 

----
===trace===
by Stuart Sierra<br>
API Overview [TraceApiDoc here]

<pre> This file defines simple "tracing" macros to help you see what your 
code is doing.</pre>
Public Variables and Functions:
[TraceApiDoc#_*trace-depth_* *trace-depth*] [TraceApiDoc#deftrace deftrace] [TraceApiDoc#trace trace] [TraceApiDoc#trace-fn-call trace-fn-call] [TraceApiDoc#trace-indent trace-indent] [TraceApiDoc#tracer tracer] 

----
===types===
by Konrad Hinsen<br>
API Overview [TypesApiDoc here]

<pre> General and algebraic data types</pre>
Public Variables and Functions:
[TypesApiDoc#defadt defadt] [TypesApiDoc#deftype deftype] [TypesApiDoc#deftype- deftype-] [TypesApiDoc#match match] 

----
===walk===
by Stuart Sierra<br>
API Overview [WalkApiDoc here]

<pre> This file defines a generic tree walker for Clojure data 
structures.  It takes any data structure (list, vector, map, set, 
seq), calls a function on every element, and uses the return value 
of the function in place of the original.  This makes it fairly 
easy to write recursive search-and-replace functions, as shown in 
the examples. 
 
Note: "walk" supports all Clojure data structures EXCEPT maps 
created with sorted-map-by.  There is no (obvious) way to retrieve 
the sorting function.</pre>
Public Variables and Functions:
[WalkApiDoc#keywordize-keys keywordize-keys] [WalkApiDoc#macroexpand-all macroexpand-all] [WalkApiDoc#postwalk postwalk] [WalkApiDoc#postwalk-demo postwalk-demo] [WalkApiDoc#postwalk-replace postwalk-replace] [WalkApiDoc#prewalk prewalk] [WalkApiDoc#prewalk-demo prewalk-demo] [WalkApiDoc#prewalk-replace prewalk-replace] [WalkApiDoc#stringify-keys stringify-keys] [WalkApiDoc#walk walk] 

----
===with-ns===
by Stuart Sierra<br>
API Overview [WithNsApiDoc here]

<pre> Temporary namespace macro</pre>
Public Variables and Functions:
[WithNsApiDoc#with-ns with-ns] [WithNsApiDoc#with-temp-ns with-temp-ns] 

----
===zip-filter===
by Chris Houser<br>
API Overview [ZipFilterApiDoc here]

<pre> System for filtering trees and nodes generated by zip.clj in 
general, and xml trees in particular.</pre>
Public Variables and Functions:
[ZipFilterApiDoc#ancestors ancestors] [ZipFilterApiDoc#children children] [ZipFilterApiDoc#children-auto children-auto] [ZipFilterApiDoc#descendants descendants] [ZipFilterApiDoc#left-locs left-locs] [ZipFilterApiDoc#leftmost? leftmost?] [ZipFilterApiDoc#right-locs right-locs] [ZipFilterApiDoc#rightmost? rightmost?] 

Variables and Functions in zip-filter.xml:
[ZipFilterApiDoc#attr attr] [ZipFilterApiDoc#attr_= attr=] [ZipFilterApiDoc#seq-test seq-test] [ZipFilterApiDoc#tag_= tag=] [ZipFilterApiDoc#text text] [ZipFilterApiDoc#text_= text=] [ZipFilterApiDoc#xml-> xml->] [ZipFilterApiDoc#xml1-> xml1->] 

