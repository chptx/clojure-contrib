#summary stream-utils API Reference
#sidebar ApiDocSidebar

<wiki:comment>
This document was auto-generated from the clojure.contrib source by contrib-autodoc.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
</wiki:comment>
=API for stream-utils=
<br>by Konrad Hinsen

Usage: 
{{{
(ns <your-namespace>
  (:use clojure.contrib.stream-utils))
}}}
==Overview==
<pre> Functions for setting up computational pipelines via data streams. 
 
NOTE: This library is experimental. It may change significantly 
      with future release. 
 
This library defines: 
- an abstract stream type, whose interface consists of the 
  multimethod stream-next 
- a macro for implementing streams 
- implementations of stream for 
  1) Clojure sequences, and vectors 
  2) nil, representing an empty stream 
- tools for writing stream transformers, including the 
  monad stream-m 
- various utility functions for working with streams 
 
Streams are building blocks in the construction of computational 
pipelines. A stream is represented by its current state plus 
a function that takes a stream state and obtains the next item 
in the stream as well as the new stream state. The state is 
implemented as a Java class or a Clojure type (as defined by the 
function clojure.core/type), and the function is provided as an 
implementation of the multimethod stream-next for this class or type. 
 
While setting up pipelines using this mechanism is somewhat more 
cumbersome than using Clojure's lazy seq mechanisms, there are a 
few advantages: 
- The state of a stream can be stored in any Clojure data structure, 
  and the stream can be re-generated from it any number of times. 
  Any number of states can be stored this way. 
- The elements of the stream are never cached, so keeping a reference 
  to a stream state does not incur an uncontrollable memory penalty. 
 
Note that the stream mechanism is thread-safe as long as the 
concrete stream implementations do not use any mutable state. 
 
Stream transformers take any number of input streams and produce one 
output stream. They are typically written using the stream-m 
monad. In the definition of a stream transformer, (pick s) returns 
the next value of stream argument s, whereas pick-all returns the 
next value of all stream arguments in the form of a vector.</pre>


==Public Variables and Functions==
Shortcuts:
[#defst defst] [#defstream defstream] [#pick pick] [#pick-all pick-all] [#stream-drop stream-drop] [#stream-filter stream-filter] [#stream-flatten stream-flatten] [#stream-m stream-m] [#stream-map stream-map] [#stream-next stream-next] [#stream-seq stream-seq] [#stream-type stream-type] 

----
===defst===
====macro====
<pre>
Usage: *(_defst_ name args streams & body)*
</pre>
<pre> Define the stream transformer name by body. 
The non-stream arguments args and the stream arguments streams 
are given separately, with args being possibly empty.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/stream_utils/clojure/contrib/stream_utils.clj#182 Source] [http://www.google.com/codesearch?hl=en&lr=&q=defst+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===defstream===
====macro====
<pre>
Usage: *(_defstream_ type-tag args & body)*
</pre>
<pre> Define object of the given type as a stream whose implementation 
of stream-next is defined by args and body. This macro adds 
a type-specific method for stream-next and derives type 
from stream-type.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/stream_utils/clojure/contrib/stream_utils.clj#72 Source] [http://www.google.com/codesearch?hl=en&lr=&q=defstream+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===pick===
====function====
<pre>
Usage: *(_pick_ n)*
</pre>
<pre> Return the next value of stream argument n inside a stream 
transformer. When used inside of defst, the name of the stream 
argument can be used instead of its index n.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/stream_utils/clojure/contrib/stream_utils.clj#148 Source] [http://www.google.com/codesearch?hl=en&lr=&q=pick+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===pick-all===
====function====
<pre>
Usage: *(_pick-all_ streams)*
</pre>
<pre> Return a vector containing the next value of each stream argument 
inside a stream transformer.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/stream_utils/clojure/contrib/stream_utils.clj#159 Source] [http://www.google.com/codesearch?hl=en&lr=&q=pick-all+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===stream-drop===
====function====
<pre>
Usage: *(_stream-drop_ n stream)*
</pre>
<pre> Return a stream containing all but the first n elements of stream.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/stream_utils/clojure/contrib/stream_utils.clj#200 Source] [http://www.google.com/codesearch?hl=en&lr=&q=stream-drop+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===stream-filter===
====multimethod====
<pre>
Usage: *(_stream-filter_ p stream)*
</pre>
<pre> Return a new stream that contrains the elements of stream 
that satisfy the predicate p.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/stream_utils/clojure/contrib/stream_utils.clj#242 Source] [http://www.google.com/codesearch?hl=en&lr=&q=stream-filter+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===stream-flatten===
====function====
<pre>
Usage: *(_stream-flatten_ s)*
</pre>
<pre> Converts a stream of sequences into a stream of the elements of the 
sequences. Flattening is not recursive, only one level of nesting 
will be removed.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/stream_utils/clojure/contrib/stream_utils.clj#270 Source] [http://www.google.com/codesearch?hl=en&lr=&q=stream-flatten+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===stream-m===
====var====
<pre> Monad describing stream computations. The monadic values can be 
of any type handled by stream-next.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/stream_utils/clojure/contrib/stream_utils.clj#134 Source] [http://www.google.com/codesearch?hl=en&lr=&q=stream-m+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===stream-map===
====multimethod====
<pre>
Usage: *(_stream-map_ f stream)*
</pre>
<pre> Return a new stream by mapping the function f on the given stream.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/stream_utils/clojure/contrib/stream_utils.clj#218 Source] [http://www.google.com/codesearch?hl=en&lr=&q=stream-map+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===stream-next===
====multimethod====
<pre>
Usage: *(_stream-next_ stream-state)*
</pre>
<pre> Returns a vector `[`next-value new-state`]` where next-value is the next 
item in the data stream defined by stream-state and new-state 
is the new state of the stream. At the end of the stream, 
next-value and new-state are nil.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/stream_utils/clojure/contrib/stream_utils.clj#90 Source] [http://www.google.com/codesearch?hl=en&lr=&q=stream-next+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===stream-seq===
====function====
<pre>
Usage: *(_stream-seq_ s)*
</pre>
<pre> Return a lazy seq on the stream. Also accessible via 
clojure.contrib.seq-utils/seq-on and 
clojure.contrib.generic.collection/seq for streams.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/stream_utils/clojure/contrib/stream_utils.clj#112 Source] [http://www.google.com/codesearch?hl=en&lr=&q=stream-seq+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
----
===stream-type===
====var====
<pre> The root type for the stream hierarchy. For each stream type, 
add a derivation from this type.</pre>

[http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/stream_utils/clojure/contrib/stream_utils.clj#68 Source] [http://www.google.com/codesearch?hl=en&lr=&q=stream-type+package%3Ahttp%3A%2F%2Fclojure-contrib\.googlecode\.com&sbtn=Search Search for references in contrib]
==Namespace clojure.contrib.stream-utils.examples==
<pre> Examples for data streams</pre>
