#summary test-is API Reference
#sidebar ApiDocSidebar

<wiki:comment>
This document was auto-generated from the clojure.contrib source by contrib-autodoc.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
</wiki:comment>
=API for test-is=
Usage: 
{{{
(ns <your-namespace>
  (:use clojure.contrib.test-is))
}}}


==Public Variables and Functions==
Shortcuts:
[#*load-tests* *load-tests*] [#*stack-trace-depth* *stack-trace-depth*] [#(_are_expr_&_args) are] [#(_assert-any_msg_form) assert-any] [#(_assert-predicate_msg_form) assert-predicate] [#(_compose-fixtures_f1_f2) compose-fixtures] [#(_deftest_name_&_body) deftest] [#(_deftest-_name_&_body) deftest-] [#(_file-position_n) file-position] [#(_function?_x) function?] [#(_get-possibly-unbound-var_v) get-possibly-unbound-var] [#(_inc-report-counter_name) inc-report-counter] [#(_is_form) is] [#(_join-fixtures_fixtures) join-fixtures] [#(_print-results_r) print-results] [#report report] [#(_run-all-tests_) run-all-tests] [#(_run-tests_) run-tests] [#(_set-test_name_&_body) set-test] [#(_test-all-vars_ns) test-all-vars] [#(_test-ns_ns) test-ns] [#(_test-var_v) test-var] [#(_testing_string_&_body) testing] [#(_testing-contexts-str_) testing-contexts-str] [#(_testing-vars-str_) testing-vars-str] [#(_try-expr_msg_form) try-expr] [#(_with-test_definition_&_body) with-test] 

Variables and Functions in test-is.tap:
[TestIsApiDoc#(_print-tap-diagnostic_data) print-tap-diagnostic] [TestIsApiDoc#(_print-tap-fail_msg) print-tap-fail] [TestIsApiDoc#(_print-tap-pass_msg) print-tap-pass] [TestIsApiDoc#(_print-tap-plan_n) print-tap-plan] [TestIsApiDoc#(_with-tap-output_&_body) with-tap-output] 

----
===`_``*`load-tests`*``_`===
<pre> True by default.  If set to false, no test functions will
be created by deftest, set-test, or with-test.  Use this to omit
tests when compiling or loading production code.</pre>
----
===`_``*`stack-trace-depth`*``_`===
<pre> The maximum depth of stack traces to print when an Exception
is thrown during a test.  Defaults to nil, which means print the 
complete stack trace.</pre>
----
===(`_`are`_` expr & args)===
====Macro====
<pre> Checks multiple assertions with a template expression.
See clojure.contrib.template/do-template for an explanation of
templates.

 Example: (are (= `_`1 `_`2)  
              2 (+ 1 1)
              4 (`*` 2 2))
Expands to: 
         (do (is (= 2 (+ 1 1)))
             (is (= 4 (`*` 2 2))))

 Note: This breaks some reporting features, such as line numbers.</pre>
----
===(`_`assert-any`_` msg form)===
<pre> Returns generic assertion code for any test, including macros, Java
method calls, or isolated symbols.</pre>
----
===(`_`assert-predicate`_` msg form)===
<pre> Returns generic assertion code for any functional predicate.  The
'expected' argument to 'report' will contains the original form, the
'actual' argument will contain the form with all its sub-forms
evaluated.  If the predicate returns false, the 'actual' form will
be wrapped in (not...).</pre>
----
===(`_`compose-fixtures`_` f1 f2)===
<pre> Composes two fixture functions, creating a new fixture function
that combines their behavior.</pre>
----
===(`_`deftest`_` name & body)===
====Macro====
<pre> Defines a test function with no arguments.  Test functions may call
other tests, so tests may be composed.  If you compose tests, you
should also define a function named test-ns-hook; run-tests will
call test-ns-hook instead of testing all vars.

 Note: Actually, the test body goes in the :test metadata on the var,
and the real function (the value of the var) calls test-var on
itself.

 When `*`load-tests`*` is false, deftest is ignored.</pre>
----
===(`_`deftest-`_` name & body)===
====Macro====
<pre> Like deftest but creates a private var.</pre>
----
===(`_`file-position`_` n)===
<pre> Returns a vector `[`filename line-number`]` for the nth call up the
stack.</pre>
----
===(`_`function?`_` x)===
<pre> Returns true if argument is a function or a symbol that resolves to
a function (not a macro).</pre>
----
===(`_`get-possibly-unbound-var`_` v)===
<pre> Like var-get but returns nil if the var is unbound.</pre>
----
===(`_`inc-report-counter`_` name)===
<pre> Increments the named counter in `*`report-counters`*`, a ref to a map.
Does nothing if `*`report-counters`*` is nil.</pre>
----
===(`_`is`_` form)===
===(`_`is`_` form msg)===
====Macro====
<pre> Generic assertion macro.  'form' is any predicate test.
'msg' is an optional message to attach to the assertion.

 Example: (is (= 4 (+ 2 2)) "Two plus two should be 4")

 Special forms:

 (is (thrown? c body)) checks that an instance of c is thrown from
body, fails if not; then returns the thing thrown.

 (is (thrown-with-msg? c re body)) checks that an instance of c is
thrown AND that the message on the exception matches (with
re-matches) the regular expression re.</pre>
----
===(`_`join-fixtures`_` fixtures)===
<pre> Composes a collection of fixtures, in order.  Always returns a valid
fixture function, even if the collection is empty.</pre>
----
===(`_`print-results`_` r)===
<pre> Prints formatted results message based on the reported counts
returned by test-ns.</pre>
----
===`_`report`_`===
<pre> Handles the result of a single assertion.  'event' is one
of :pass, :fail, or :error.  'msg' is a comment string associated
with the assertion.  'expected' and 'actual' are quoted forms,
which will be rendered with pr-str.

 Special case: if 'event' is :info, just the 'msg' will be
printed.

 You can rebind this function during testing to plug in your own
test-reporting framework.</pre>
----
===(`_`run-all-tests`_`)===
<pre> Runs all tests in all namespaces; prints results.</pre>
----
===(`_`run-tests`_`)===
===(`_`run-tests`_` & namespaces)===
<pre> Runs all tests in the given namespaces; prints results.
Defaults to current namespace if none given.</pre>
----
===(`_`set-test`_` name & body)===
====Macro====
<pre> Experimental.
Sets :test metadata of the named var to a fn with the given body.
The var must already exist.  Does not modify the value of the var.

 When `*`load-tests`*` is false, set-test is ignored.</pre>
----
===(`_`test-all-vars`_` ns)===
<pre> Calls test-var on every var interned in the namespace, with fixtures.</pre>
----
===(`_`test-ns`_` ns)===
<pre> If the namespace defines a function named test-ns-hook, calls that.
Otherwise, calls test-all-vars on the namespace.  'ns' is a
namespace object or a symbol.

 Internally binds `*`report-counters`*` to a ref initialized to
`*`inital-report-counters`*`.  Returns the final, dereferenced state of
`*`report-counters`*`.</pre>
----
===(`_`test-var`_` v)===
<pre> If v has a function in its :test metadata, calls that function,
with `*`testing-vars`*` bound to (conj `*`testing-vars`*` v).</pre>
----
===(`_`testing`_` string & body)===
====Macro====
<pre> Adds a new string to the list of testing contexts.  May be nested,
but must occur inside a test function (deftest).</pre>
----
===(`_`testing-contexts-str`_`)===
<pre> Returns a string representation of the current test context. Joins
strings in `*`testing-contexts`*` with spaces.</pre>
----
===(`_`testing-vars-str`_`)===
<pre> Returns a string representation of the current test.  Renders names
in `*`testing-vars`*` as a list, then the source file and line of
current assertion.</pre>
----
===(`_`try-expr`_` msg form)===
====Macro====
<pre> Used by the 'is' macro to catch unexpected exceptions.
You don't call this.</pre>
----
===(`_`with-test`_` definition & body)===
====Macro====
<pre> Takes any definition form (that returns a Var) as the first argument.
Remaining body goes in the :test metadata function for that Var.

 When `*`load-tests`*` is false, only evaluates the definition, ignoring
the tests.</pre>
==Namespace clojure.contrib.test-is.tap==
----
===(`_`print-tap-diagnostic`_` data)===
<pre> Prints a TAP diagnostic line.  data is a (possibly multi-line)
string.</pre>
----
===(`_`print-tap-fail`_` msg)===
<pre> Prints a TAP 'not ok' line.  msg is a string, with no line breaks</pre>
----
===(`_`print-tap-pass`_` msg)===
<pre> Prints a TAP 'ok' line.  msg is a string, with no line breaks</pre>
----
===(`_`print-tap-plan`_` n)===
<pre> Prints a TAP plan line like '1..n'.  n is the number of tests</pre>
----
===(`_`with-tap-output`_` & body)===
====Macro====
<pre> Execute body with modified test-is reporting functions that produce
TAP output</pre>
