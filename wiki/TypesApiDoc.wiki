#summary types API Reference
#sidebar ApiDocSidebar

<wiki:comment>
This document was auto-generated from the clojure.contrib source by contrib-autodoc.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
</wiki:comment>
=API for types=
Usage: 
{{{
(ns <your-namespace>
  (:use clojure.contrib.types))
}}}
==Overview==
<pre> General and algebraic data types

 NOTE: This library is experimental. It may change significantly
with future release.</pre>


==Public Variables and Functions==
Shortcuts:
[#(_defadt_type-tag_&_constructors) defadt] [#(_deftype_type-tag_constructor-name_docstring?_attr-map?) deftype] [#(_deftype-_type-tag_constructor-name_&_optional) deftype-] [#(_match_value_&_clauses) match] 

Variables and Functions in types.examples:
[TypesApiDoc#multiset multiset] 

----
===(`_`defadt`_` type-tag & constructors)===
====Macro====
<pre> Define an algebraic data type name by an exhaustive list of constructors.
Each constructor can be a symbol (argument-free constructor) or a
list consisting of a tag symbol followed by the argument symbols.
The data type tag must be a keyword.</pre>
----
===(`_`deftype`_` type-tag constructor-name docstring? attr-map?)===
===(`_`deftype`_` type-tag constructor-name docstring? attr-map? constructor)===
===(`_`deftype`_` type-tag constructor-name docstring? attr-map? constructor deconstructor)===
====Macro====
<pre> Define a data type by a type tag (a namespace-qualified keyword)
and a symbol naming the constructor function. Optionally, a
constructor and a deconstructor function can be given as well,
the defaults being clojure.core/identity and clojure.core/list.
The full constructor associated with constructor-name calls the
constructor function and attaches the type tag to its result
as metadata. The deconstructor function must return the arguments
to be passed to the constructor in order to create an equivalent
object. It is used for printing and matching.</pre>
----
===(`_`deftype-`_` type-tag constructor-name & optional)===
====Macro====
<pre> Same as deftype but the constructor is private.</pre>
----
===(`_`match`_` value & clauses)===
====Macro====
<pre> Given a value and a list of template-expr clauses, evaluate the first
expr whose template matches the value. There are four kinds of templates:
1) Lists of the form (tag x1 x2 ...) match instances of types
   whose constructor has the same form as the list.
2) Quoted lists of the form '(x1 x2 ...) match lists of the same
   length.
3) Vectors of the form `[`x1 x2 ...`]` match vectors of the same length.
4) Maps of the form {:key1 x1 :key2 x2 ...} match maps that have
   the same keys as the template, but which can have additional keys
   that are not part of the template.
The values x1, x2, ... can be symbols or non-symbol values. Non-symbols
must be equal to the corresponding values in the object to be matched.
Symbols will be bound to the corresponding value in the object in the
evaluation of expr. If the same symbol occurs more than once in a,
template the corresponding elements of the object must be equal
for the template to match.</pre>
==Namespace clojure.contrib.types.examples==
----
===`_`multiset`_`===
<pre> Multiset (demo implementation)</pre>
