#summary zip-filter API Reference
#sidebar ApiDocSidebar

<wiki:comment>
This document was auto-generated from the clojure.contrib source by contrib-autodoc.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
</wiki:comment>
=API for zip-filter=
Usage: 
{{{
(ns <your-namespace>
  (:use clojure.contrib.zip-filter))
}}}


==Public Variables and Functions==
Shortcuts:
[#(_ancestors_loc) ancestors] [#(_children_loc) children] [#(_children-auto_loc) children-auto] [#(_descendants_loc) descendants] [#(_left-locs_loc) left-locs] [#(_leftmost?_loc) leftmost?] [#(_right-locs_loc) right-locs] [#(_rightmost?_loc) rightmost?] 

Variables and Functions in zip-filter.xml:
[ZipFilterApiDoc#(_attr_attrname) attr] [ZipFilterApiDoc#(_attr=_attrname_attrval) attr=] [ZipFilterApiDoc#(_seq-test_preds) seq-test] [ZipFilterApiDoc#(_tag=_tagname) tag=] [ZipFilterApiDoc#(_text_loc) text] [ZipFilterApiDoc#(_text=_s) text=] [ZipFilterApiDoc#(_xml->_loc_&_preds) xml->] [ZipFilterApiDoc#(_xml1->_loc_&_preds) xml1->] 

----
===(_ancestors_ loc)===
<pre>Returns a lazy sequence of all ancestors of location loc, starting
with loc and proceeding to loc's parent node and on through to the
root of the tree.</pre>
----
===(_children_ loc)===
<pre>Returns a lazy sequence of all immediate children of location loc,
left-to-right.</pre>
----
===(_children-auto_ loc)===
<pre>Returns a lazy sequence of all immediate children of location loc,
left-to-right, marked so that a following tag= predicate will auto-descend.</pre>
----
===(_descendants_ loc)===
<pre>Returns a lazy sequence of all descendants of location loc, in
depth-first order, left-to-right, starting with loc.</pre>
----
===(_left-locs_ loc)===
<pre>Returns a lazy sequence of locations to the left of loc, starting with loc.</pre>
----
===(_leftmost?_ loc)===
<pre>Returns true if there are no more nodes to the left of location loc.</pre>
----
===(_right-locs_ loc)===
<pre>Returns a lazy sequence of locations to the right of loc, starting with loc.</pre>
----
===(_rightmost?_ loc)===
<pre>Returns true if there are no more nodes to the right of location loc.</pre>
==Namespace clojure.contrib.zip-filter.xml==
----
===(_attr_ attrname)===
===(_attr_ loc attrname)===
<pre>Returns the xml attribute named attrname, of the xml node at location loc.</pre>
----
===(_attr=_ attrname attrval)===
<pre>Returns a query predicate that matches a node when it has an
attribute named attrname whose value is attrval.</pre>
----
===(_seq-test_ preds)===
<pre>Returns a query predicate that matches a node when its xml content
matches the query expresions given.</pre>
----
===(_tag=_ tagname)===
<pre>Returns a query predicate that matches a node when its is a tag
named tagname.</pre>
----
===(_text_ loc)===
<pre>Returns the textual contents of the given location, similar to
xpaths's value-of</pre>
----
===(_text=_ s)===
<pre>Returns a query predicate that matches a node when its textual
content equals s.</pre>
----
===(_xml->_ loc & preds)===
<pre>The loc is passed to the first predicate.  If the predicate returns
a collection, each value of the collection is passed to the next
predicate.  If it returns a location, the location is passed to the
next predicate.  If it returns true, the input location is passed to
the next predicate.  If it returns false or nil, the next predicate
is not called.

This process is repeated, passing the processed results of each
predicate to the next predicate.  xml-> returns the final sequence.
The entire chain is evaluated lazily.

There are also special predicates: keywords are converted to tag=,
strings to text=, and vectors to sub-queries that return true if
they match.

See the footer of zip-query.clj for examples.</pre>
----
===(_xml1->_ loc & preds)===
<pre>Returns the first item from loc based on the query predicates
given.  See xml-></pre>
